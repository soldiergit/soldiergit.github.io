

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/resource/img/favicon.png">
  <link rel="icon" type="image/png" href="/resource/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="soldier">
  <meta name="keywords" content="">
  <title>Spring框架面试总结 - 黄结的个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>soldier</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/about/">
                    
                    个人简历
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" target="_blank" rel="noopener" href="https://soldiergit.github.io/honor/">
                    
                    项目及获奖
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-11-18 15:49" pubdate>
        2020年11月18日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      64
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Spring框架面试总结</h1>
            
            <div class="markdown-body" id="post-body">
              <h2 id="Spring是什么？"><a href="#Spring是什么？" class="headerlink" title="Spring是什么？"></a>Spring是什么？</h2><p><font color=#FF000>Spring</font>是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：<strong>基于XML的配置</strong>、<strong>基于注解的配置</strong>、<strong>基于Java的配置</strong>。<br>主要由以下几个模块组成：</p>
<ul>
<li><strong>Spring Core</strong>：核心类库，提供IoC服务；</li>
<li><strong>Spring Context</strong>：提供框架式的Bean访问方式，以及企业级功能（<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/JNDI">JNDI</a>、定时任务等）；</li>
<li><strong>Spring AOP</strong>：AOP服务；</li>
<li><strong>Spring DAO</strong>：对JDBC的抽象，简化了数据访问异常的处理；</li>
<li><strong>Spring ORM</strong>：对现有的ORM框架的支持；</li>
<li><strong>Spring Web</strong>：提供了基本的面向Web的综合特性，例如多文件上传；</li>
<li><strong>Spring MVC</strong>：提供面向Web应用的Model-View-Controller实现；</li>
</ul>
<h2 id="Spring的优点是什么？"><a href="#Spring的优点是什么？" class="headerlink" title="Spring的优点是什么？"></a>Spring的优点是什么？</h2><ol>
<li>Spring属于低侵入式设计，代码的污染极低；</li>
<li>Spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；</li>
<li>Spring提供了AOP技术，支持将一些通用的任务，如：安全、事务、日志、权限等进行集中式管理，从而提供更好的复用；</li>
<li>Spring对主流的应用框架提供了集成支持。</li>
</ol>
<h2 id="Spring的AOP理解"><a href="#Spring的AOP理解" class="headerlink" title="Spring的AOP理解"></a>Spring的AOP理解</h2><p>&nbsp;&nbsp;OOP面向对象。允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的应用。<br>&nbsp;&nbsp;<strong>AOP</strong>，一般称为面向切面，作为面向对象的一种补充，<font color=#FF000>用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块</font>，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。<br>&nbsp;&nbsp;<strong>AOP实现的关键</strong>在于代理模式，AOP代理主要分为<strong>静态代理</strong>和<strong>动态代理</strong> 。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。<br>(1) <strong>AspectJ是静态代理的增强</strong>，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，它会在编译阶段将AspectJ（切面）织入到Java字节码中，运行的时候就是增强之后的AOP对象。<br>(2) <strong>Spring AOP使用的是动态代理</strong>，所谓动态代理，就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<p><strong><code>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理</code></strong> ：</p>
<ol>
<li>JDK动态代理只提供接口的代理，不支持类的代理，核心是InvocationHandler接口和Proxy类，InvocationHandler通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着Proxy类利用InvocationHandler接口动态创建一个符合某一接口的实例，生成目标类的代理对象。<blockquote>
<p>InvocationHandler的invoke(Object  proxy,Method  method,Object[] args)方法参数解析：</p>
<blockquote>
<p>proxy：是最终生成的代理实例；<br>method：是被代理目标实例的某个具体方法；<br>args：是被代理目标实例某个方法的具体入参，在方法反射调用时使用。</p>
</blockquote>
</blockquote>
</li>
<li>如果代理类没有实现InvocationHandler接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Core Generation Library）是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li>
<li><strong>静态代理与动态代理的区别</strong>在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</li>
</ol>
<h2 id="Spring的IoC理解"><a href="#Spring的IoC理解" class="headerlink" title="Spring的IoC理解"></a>Spring的IoC理解</h2><ol>
<li><code>IoC就是控制反转</code>，是指创建对象的控制权的转移，以前创建对象的主动权时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。<code>DI依赖注入</code>，和控制反转是同一个概念的不同角度的描述，即：应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。</li>
<li>最直观的表达就是，IoC让对象的创建不用去 new 了，可以由Spring自动生产，使用Java的反射机制，根据配置文件在程序运行时动态的去创建对象以及管理对象，并调用对象的方法。</li>
<li>Spring的IoC有三种注入方式：构造器注入、setter方法注入、根据注解注入。</li>
</ol>
<blockquote>
<p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p>
</blockquote>
<h2 id="BeanFactory和ApplicationContext的区别？"><a href="#BeanFactory和ApplicationContext的区别？" class="headerlink" title="BeanFactory和ApplicationContext的区别？"></a>BeanFactory和ApplicationContext的区别？</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>
<ol>
<li><strong>BeanFactory</strong>：是Spring里面最底层的接口，包含了各种Bean的定义，读取Bean配置文档，管理Bean的加载、实例化，控制Bean的生命周期，维护Bean之间的依赖关系。<strong>ApplicationContext</strong>作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的架构功能：<br>&nbsp;&nbsp;&nbsp;&nbsp;① 继承MessageSource，因此支持国际化；<br>&nbsp;&nbsp;&nbsp;&nbsp;② 统一的资源文件访问方式；<br>&nbsp;&nbsp;&nbsp;&nbsp;③ 提供在监听器中注册Bean的事件；<br>&nbsp;&nbsp;&nbsp;&nbsp;④ 同时加载多个配置文件；<br>&nbsp;&nbsp;&nbsp;&nbsp;⑤ 载入多个（有继承关系）上下文，使用每一个上下文对象都专注于一个特定的层次，比如应用的web层。</li>
<li><font color=#0000FF>BeanFactory采用的是延迟加载的形式来注入Bean的，即只有在使用到某个Bean时（调用getBean()），才对该Bean进行加载实例化。</font>弊端是：不能及时发现一些存在的Spring配置问题，如果Bean的某一个属性没有注入，BeanFactory加载后直到第一次调用getBean方法才会抛出异常。<br><font color=#0000FF>ApplicationContext是在容器启动时，一次性创建了所有的Bean</font>，可以及时发现Spring配置中存在的错误，利于检查所依赖属性是否注入。ApplicationContext启动后预载入所有单例的Bean，通过预载入单例Bean确保需要时无需等待，因为它们已经创建好了。<br>相对于基本的BeanFactory，<font color=#0000FF>ApplicationContext唯一不足是占用内存空间</font>，当应用程序配置的Bean较多时程序启动较慢。</li>
<li>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如：使用ContextLoader；</li>
<li>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的<strong>区别</strong>是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</li>
</ol>
<h2 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h2><p>首先说一下Servlet的生命周期：实例化 &rarr; 初始init &rarr; 接收请求service &rarr; 销毁destroy；<br>Spring上下文中的Bean生命周期也类似：<br><font color=#0000FF><strong>（1）实例化Bean：</strong></font><br>对于BeanFactory容器，当客户向容器请求一个尚未初始化的Bean时，或初始化Bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的Bean。</p>
<p><font color=#0000FF><strong>（2）设置对象属性（依赖注入）：</strong></font><br>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息以及通过BeanWrapper提供的设置属性的接口完成依赖注入。</p>
<p><font color=#0000FF><strong>（3）处理Aware接口：</strong></font><br>接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：<br>① 如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；<br>② 如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的事Spring工厂本身；<br>③ 如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext context)方法，传入Spring上下文对象</p>
<p><font color=#0000FF><strong>（4）BeanPostProcessor：</strong></font><br>如果想对Bean进行一些自定义的处理，那么可以让Bean实现BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p>
<p><font color=#0000FF><strong>（5）InitializingBean 与init-method：</strong></font><br>如果Bean在Spring配置文件中配置了init-method属性，则会自动调用其配置的初始化方法。</p>
<p><font color=#0000FF><strong>（6）如果这个Bean走了第四步：</strong></font><br>如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束之后调用的，所以可应用于内存或缓存技术；</p>
<p><code>以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。</code>&uarr;&uarr;&uarr;</p>
<p><font color=#0000FF><strong>（7）DisposableBean(清理)：</strong></font><br>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p>
<p><font color=#0000FF><strong>（8）destroy-method：</strong></font><br>最后，如果这个Bean的Spring配置中配置了destroy-method属性，就会自动调用其配置的销毁方法。</p>
<h2 id="Spring-Bean-Scope-作用域"><a href="#Spring-Bean-Scope-作用域" class="headerlink" title="Spring Bean Scope(作用域)"></a>Spring Bean Scope(作用域)</h2><p>Spring容器中的Bean可以分为5个范围：</p>
<ol>
<li><strong>singleton</strong>：<font color=#FF000>默认</font>，每个容器中只有一个Bean的实例，单例模式由BeanFactory自身维护；</li>
<li><strong>prototype</strong>：为每一个Bean请求提供一个实例；</li>
<li><strong>request</strong>：为每一个网络请求创建一个实例，在请求完成后，Bean会失效并被垃圾回收器回收；</li>
<li><strong>session</strong>：与request范围类似，确保每个session中有一个Bean实例，在session过期后，Bean会随之失效；</li>
<li><strong>global-session</strong>：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很对portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这个全局变量需要存储在global-session中。全局作用域与Servlet的session作用域效果相同。</li>
</ol>
<h2 id="Spring框架中的单例Beans是线程安全的吗？"><a href="#Spring框架中的单例Beans是线程安全的吗？" class="headerlink" title="Spring框架中的单例Beans是线程安全的吗？"></a>Spring框架中的单例Beans是线程安全的吗？</h2><p>Spring框架并没有对单例Bean进行任何多线程的封装处理。关于单例Bean的线程安全和并发问题需要开发者自行去搞定，但实际上大部分的Spring Bean并没有可变的状态（比如Serview类和DAO类），所以在某种程度上说Spring的单例Bean是线程安全的。如果Bean有多种状态的话（比如View Model对象），就需要自行保证线程安全。最浅显的<strong>解决办法</strong>就是将多态Bean的作用域由“<strong>singleton</strong>”变更为“<strong>prototype</strong>”。</p>
<h2 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h2><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用<font color=#0000FF>ThreadLocal进行处理，解决线程安全问题</font>；<br>ThreadLocal和线程同步机制都是为了解决多线程中相同变量访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“时间换空间”的方式。<br>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本（JMM内存模型），从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<h2 id="Spring注入Bean的几种方式"><a href="#Spring注入Bean的几种方式" class="headerlink" title="Spring注入Bean的几种方式"></a>Spring注入Bean的几种方式</h2><ol>
<li>set方法注入；</li>
<li>构造器注入：①通过index设置参数位置；②通过type设置参数类型；</li>
<li>静态工厂注入；</li>
<li>实例工厂；</li>
</ol>
<h2 id="Spring的自动装配"><a href="#Spring的自动装配" class="headerlink" title="Spring的自动装配"></a>Spring的自动装配</h2><p>在Spring中，对象无需自己查找或创建与其关联的其它对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用Autowire来自动装载模式。<br>在Spring框架xml配置中共有5中自动装配：</p>
<ol>
<li><strong>no</strong>：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配Bean；</li>
<li><strong>byName</strong>：通过Bean的名称进行自动装配，如果一个Bean的property与另一个Bean的name相同，就进行自动装配；</li>
<li><strong>byType</strong>：通过参数的数据类型进行自动装配；</li>
<li><strong>constructor</strong>：利用构造函数进行装配，并且构造函数的参数通过byType进行装配；</li>
<li><strong>autodetect</strong>：自动探测，如果有构造方法，则通过constructor方式进行自动装配，否则使用byType方式；</li>
</ol>
<p>基于注解的方式：<br>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>
<ul>
<li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>
<li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li>
<li>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</li>
</ul>
<h2 id="Spring中用到了哪些设计模式？"><a href="#Spring中用到了哪些设计模式？" class="headerlink" title="Spring中用到了哪些设计模式？"></a>Spring中用到了哪些设计模式？</h2><ol>
<li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</li>
<li>单例模式：Bean默认为单例模式；</li>
<li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li>
<li>模板模式：用来解决代码重复的问题，比如：RestTemplate、JmsTemplate、JpaTemplate；</li>
<li>观察者模式：定义对象见一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象就会得到通知被制动更新，如Spring中listener的实现——ApplicationListener。</li>
</ol>
<h2 id="Component和-Bean的区别是什么？"><a href="#Component和-Bean的区别是什么？" class="headerlink" title="@Component和@Bean的区别是什么？"></a>@Component和@Bean的区别是什么？</h2><ol>
<li><code>作用对象不同</code>：@Component注解作用于类，而@Bean注解作用于方法；</li>
<li><code>@Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中(我们可以使用@ComponentScan注解定义要扫描的路径</code>。@Bean注解通常是我们在标有该注解的方法中定义产生这个Bean，@Bean告诉Spring这个是某个类的实例，当需要时还给我；</li>
<li><code>@Bean注解比@Component注解的自定义性更强</code>，而且很多地方我们只能通过@Bean注解来注册Bean，比如当我们引用第三方库中的类需要装配到Spring容器时，只能通过@Bean来实现。</li>
</ol>
<p>@Bean注解使用实例：</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl();
    &#125;
&#125;</code></pre>
<p>上面的代码相当于下面的xml配置：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transferService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.soldier.TransferServiceImpl&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre>
<p>下面这个例子无法通过@Component实现：</p>
<pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> OneService <span class="hljs-title">getService</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status)</span> </span>&#123;
    <span class="hljs-keyword">case</span> (status)  &#123;
        when <span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> serviceImpl1();
        when <span class="hljs-number">2</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> serviceImpl2();
    &#125;
&#125;</code></pre>

<h2 id="类声明为Spring的Bean的注解有哪些？"><a href="#类声明为Spring的Bean的注解有哪些？" class="headerlink" title="类声明为Spring的Bean的注解有哪些？"></a>类声明为Spring的Bean的注解有哪些？</h2><ul>
<li><strong>@Component</strong>：通用的注解，可标注任意类为 Spring 组件。</li>
<li><strong>@Repository</strong>：对应DAO层，主要同于数据库相关操作；</li>
<li><strong>@Service</strong>：对应服务层，主要涉及一些复杂的逻辑，需要用到DAO层；</li>
<li><strong>@Controller</strong>：对应Spring MVC控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h2 id="Spring管理事务的方式有几种？"><a href="#Spring管理事务的方式有几种？" class="headerlink" title="Spring管理事务的方式有几种？"></a>Spring管理事务的方式有几种？</h2><ol>
<li><strong>编程式事务</strong>，在代码中硬编程，<code>不推荐</code>；</li>
<li><strong>声明式事务</strong>，在配置文件中配置，<code>推荐</code>，共分为两种：<ol>
<li>基于XML的声明式事务；</li>
<li>基于注解的声明式事务。</li>
</ol>
</li>
</ol>
<h2 id="Spring的事务传播行为"><a href="#Spring的事务传播行为" class="headerlink" title="Spring的事务传播行为"></a>Spring的事务传播行为</h2><ol>
<li><strong>PROPAGATION_REQUIRED</strong>：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</li>
<li><strong>PROPAGATION_SUPPORTS</strong>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。‘</li>
<li><strong>PROPAGATION_MANDATORY</strong>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li>
<li><strong>PROPAGATION_REQUIRES_NEW</strong>：创建新事务，无论当前存不存在事务，都创建新事务。</li>
<li><strong>PROPAGATION_NOT_SUPPORTED</strong>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li><strong>PROPAGATION_NEVER</strong>：以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li><strong>PROPAGATION_NESTED</strong>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</li>
</ol>
<h2 id="Spring事务中的隔离级别有哪几种"><a href="#Spring事务中的隔离级别有哪几种" class="headerlink" title="Spring事务中的隔离级别有哪几种?"></a>Spring事务中的隔离级别有哪几种?</h2><ol>
<li><strong>ISOLATION_DEFAULT</strong>：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。</li>
<li><strong>ISOLATION_READ_UNCOMMITTED</strong>：读未提交，允许另外一个事务可以看到这个事务未提交的数据。</li>
<li><strong>ISOLATION_READ_COMMITTED</strong>：读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新。</li>
<li><strong>ISOLATION_REPEATABLE_READ</strong>：可重复读，保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新。</li>
<li><strong>ISOLATION_SERIALIZABLE</strong>：一个事务在执行的过程中完全看不到其他事务对数据库所做的更新。</li>
</ol>
<h2 id="SpringMVC的工作原理了解嘛？"><a href="#SpringMVC的工作原理了解嘛？" class="headerlink" title="SpringMVC的工作原理了解嘛？"></a>SpringMVC的工作原理了解嘛？</h2><p><img src="/resource/img/java/SpringMVC.jpg" srcset="/img/loading.gif"><br><font color=#FF000><strong>流程说明</strong>：</font></p>
<ol>
<li>客户端发送请求，直接请求到 DispatcherServlet；</li>
<li>DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler；</li>
<li>解析得到的这个Handler（也就是我们平时说的Controller）后，开始由 HandlerAdapter 适配器处理；</li>
<li>HandlerAdapter 会根据 Handler（Controller控制器） 来调用真正的处理器处理请求，并处理相应的业务逻辑。处理完成后会返回一个 ModelAndView 对象：Model是返回的数据对象、View是个逻辑上的View；</li>
<li>ViewResolver 会根据逻辑 View 查找实际的View；</li>
<li>DispatcherServlet 把返回的Model 传给 View 进行视图渲染；</li>
<li>最后把View 返回给客户端。</li>
</ol>
<h2 id="SpringMVC的常用注解"><a href="#SpringMVC的常用注解" class="headerlink" title="SpringMVC的常用注解"></a>SpringMVC的常用注解</h2><h3 id="1-组件型"><a href="#1-组件型" class="headerlink" title="1.组件型"></a>1.组件型</h3><p>作用于类上，将其声明为Spring的Bean，然后统一管理。</p>
<ul>
<li>@Component：通用的注解，可标注任意类为 Spring 组件。</li>
<li>@Repository：对应DAO层，主要同于数据库相关操作；</li>
<li>@Service：对应服务层，主要涉及一些复杂的逻辑，需要用到DAO层；</li>
<li>@Controller：对应Spring MVC控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h3 id="2-请求和参数型"><a href="#2-请求和参数型" class="headerlink" title="2.请求和参数型"></a>2.请求和参数型</h3><ol>
<li><code>@RequestMapping</code>：用于处理请求地址映射，可以作用于类和方法上<br> 1.1 value：定义request请求的映射地址<br> 1.1 method：定义地request址请求的方式，包括【GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE.】默认接受get请求，如果请求方式和定义的方式不一样则请求无法成功。<br> 1.1 params：定义request请求中必须包含的参数值。<br> 1.1 headers：定义request请求中必须包含某些指定的请求头，如：RequestMapping(value = “/something”, headers = “content-type=text/*”)说明请求中必须要包含”text/html”, “text/plain”这中类型的Content-type头，才是一个匹配的请求。<br> 1.1 consumes：定义请求提交内容的类型。<br> 1.1 produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/requestTest.do&quot;,params = &#123;&quot;name=sdf&quot;&#125;,headers = &#123;&quot;Accept-Encoding=gzip, deflate, br&quot;&#125;,method = RequestMethod.GET)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndex</span><span class="hljs-params">()</span></span>&#123;
    System.out.println(<span class="hljs-string">&quot;请求成功&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;
&#125;</code></pre></li>
<li><code>@RequestParam</code>：用于获取传入参数的值<br> 2.1 value：参数的名称<br> 2.1 required：定义该传入参数是否必须，默认为true，（和@RequestMapping的params属性有点类似）<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/requestParams1.do&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">requestParams1</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(required = false)</span> String name)</span></span>&#123;
    System.out.println(<span class="hljs-string">&quot;name = &quot;</span>+name);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;
&#125;</code></pre></li>
<li><code>@PathVariable</code>：用于定义路径参数值<br> 3.1 value：参数的名称<br> 3.1 required：定义传入参数是否为必须值<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/&#123;myname&#125;/pathVariable2.do&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pathVariable2</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;myname&quot;)</span> String name)</span></span>&#123;
    System.out.println(<span class="hljs-string">&quot;myname = &quot;</span>+name);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;
&#125;</code></pre></li>
<li><code>@ResponseBody</code>：作用于方法上，可以将整个返回结果以某种格式返回，如json或xml格式<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/&#123;myname&#125;/pathVariable2.do&quot;)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pathVariable2</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;myname&quot;)</span> String name)</span></span>&#123;
    System.out.println(<span class="hljs-string">&quot;myname = &quot;</span>+name);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;
&#125;</code></pre></li>
<li><code>@ModelAttribute</code>：用于把参数保存到model中，可以注解方法或参数，注解在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session（前提时要有@SessionAttributes注解） 或模型属性中，@ModelAttribute(“attributeName”) 在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称。　<pre><code class="hljs java"><span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> UserEntity <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;
    UserEntity userEntityr = <span class="hljs-keyword">new</span> UserEntity();
    userEntityr.setUsername(<span class="hljs-string">&quot;asdf&quot;</span>);
    <span class="hljs-keyword">return</span> userEntityr;
&#125;

<span class="hljs-meta">@RequestMapping(&quot;/modelTest.do&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsers</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span> UserEntity user)</span></span>&#123;
    System.out.println(user.getUsername());
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index&quot;</span>;
&#125;</code></pre></li>
<li><code>@SessionAttributes</code>：默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中。配合@ModelAttribute(“user”)使用的时候,会将对应的名称的model值存到session中<pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span>
<span class="hljs-meta">@SessionAttributes(value = &#123;&quot;user&quot;,&quot;test1&quot;&#125;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span></span>&#123;
    <span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> UserEntity <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;
        UserEntity userEntityr = <span class="hljs-keyword">new</span> UserEntity();
        userEntityr.setUsername(<span class="hljs-string">&quot;asdf&quot;</span>);
        <span class="hljs-keyword">return</span> userEntityr;
    &#125;

    <span class="hljs-meta">@RequestMapping(&quot;/modelTest.do&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsers</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span> UserEntity user ,HttpSession session)</span></span>&#123;
        System.out.println(user.getUsername());
        System.out.println(session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>));
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index&quot;</span>;
    &#125;
&#125;</code></pre>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
                    
                      <a class="hover-with-bg" href="/tags/Java%E9%9D%A2%E8%AF%95%E9%A2%98/">Java面试题</a>
                    
                      <a class="hover-with-bg" href="/tags/Spring%EF%BC%8C-%E6%A1%86%E6%9E%B6/">Spring， 框架</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/11/20/java/MySQL/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MySQL学习笔记及面试题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/17/java/HTTP/">
                        <span class="hidden-mobile">HTTP学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://soldiergit.github.io/" target="_blank" rel="nofollow noopener"><span>Copyright © 2020 soldier Powered by Hexo Fluid Core on Kubernetes</span></a> <i class="iconfont icon-love"></i> <a href="mailto:soldier_wyyx@163.com"><span>联系我</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Spring框架面试总结&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?28d1b3a306f2b9f13ed66ffd0d5a0a9a";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  
    <!-- Tencent Analytics -->
    <script defer>
      var _mtac = {};
      (function () {
        var mta = document.createElement("script");
        mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
        mta.setAttribute("name", "MTAH5");
        mta.setAttribute("sid", "500732630");
        
        mta.setAttribute("cid", "500732632");
        
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(mta, s);
      })();
    </script>
  

  
    <!-- 51.la Analytics -->
    <script defer type="text/javascript" src="//js.users.51.la/20973747.js"></script>
  

  





</body>
</html>
