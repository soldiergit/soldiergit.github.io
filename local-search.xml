<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Travis-ci+Hexo+GithubPages搭建个人博客</title>
    <link href="/2021/05/12/ci/travis-ci/IntoGithubPages/"/>
    <url>/2021/05/12/ci/travis-ci/IntoGithubPages/</url>
    
    <content type="html"><![CDATA[<h2 id="1-本地搭建博客框架"><a href="#1-本地搭建博客框架" class="headerlink" title="1.本地搭建博客框架"></a>1.本地搭建博客框架</h2><ol><li><p>安装node.js，最好是10这个版本的</p><ol><li><p>windows10下<br>链接：<a href="https://pan.baidu.com/s/1gS0UEbEeicHlMaXUe-pgYw">https://pan.baidu.com/s/1gS0UEbEeicHlMaXUe-pgYw</a>  提取码：4n2c </p></li><li><p>Ubuntu下：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 更新软件 </span>sudo apt remove --purge nodejs npmsudo apt cleansudo apt autocleansudo apt install -fsudo apt autoremove<span class="hljs-meta">#</span><span class="bash"> 安装</span>sudo apt install curlcurl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -sudo apt-get install -y nodejscurl -sL https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -sudo apt-get update &amp;&amp; sudo apt-get install yarn</code></pre></li><li><p>npm换源</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> npm换源</span>npm config set registry https://registry.npm.taobao.org<span class="hljs-meta">#</span><span class="bash">如果只是临时改变源，可以这样</span>npm --registry=https://registry.npm.taobao.org<span class="hljs-meta">#</span><span class="bash"> 更新</span>npm install -g npm</code></pre></li></ol></li><li><p>创建博客</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 全局安装hexo</span>npm install hexo-cli -g<span class="hljs-meta">#</span><span class="bash"> 创建项目</span>hexo init Github用户名.github.io<span class="hljs-meta">#</span><span class="bash"> 安装依赖</span>npm install<span class="hljs-meta">#</span><span class="bash"> 安装主题（去Hexo官网选择自己喜欢的博客主题）</span>npm install --save hexo-theme-fluid<span class="hljs-meta">#</span><span class="bash"> 启动项目</span>npm run server<span class="hljs-meta">#</span><span class="bash"> 访问http://localhost:4000查看效果</span></code></pre></li></ol><h2 id="2-Github配置"><a href="#2-Github配置" class="headerlink" title="2.Github配置"></a>2.Github配置</h2><ol><li><p>创建一个<code>用户名.github.io</code>的public类型的仓库，不要新建Readme.md文件</p></li><li><p>创建Github访问令牌：<a href="https://www.cnblogs.com/soldier-cnblogs/p/13386848.html">教程</a></p></li><li><p>创建一个<code>resource</code>分支，将其设置为主分支<br><img src="/resource/img/ci/T_GithubPages_1.png" alt="img"></p></li><li><p><del>手动部署项目</del></p><ol><li><p>先提交一次到Github</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在项目根目录初始化</span>git init<span class="hljs-meta">#</span><span class="bash"> 设置远程仓库</span>git remote add origin https://github.com/soldiergit/soldiergit.github.io.git<span class="hljs-meta">#</span><span class="bash"> 添加</span>git add .<span class="hljs-meta">#</span><span class="bash"> 提交信息</span>git commit -m &#x27;init commit&#x27;<span class="hljs-meta">#</span><span class="bash"> 提交项目(注意这个分支是源码分支，不是GithubPages页面分支-是master)</span>git push origin resource</code></pre></li><li><p>配置<code> _config.yml</code></p><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><span class="hljs-comment"># 部署到的仓库</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/soldiergit/soldiergit.github.io</span><span class="hljs-comment"># 部署到的分支(GithubPages页面分)</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre></li><li><p>部署</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 项目根目录输入</span>hexo deploy<span class="hljs-meta">#</span><span class="bash"> 输入GitHub用户名密码即可完成部署</span></code></pre></li></ol></li></ol><h2 id="3-Travis-ci配置"><a href="#3-Travis-ci配置" class="headerlink" title="3.Travis-ci配置"></a>3.Travis-ci配置</h2><ol><li>使用github账号授权登录 <a href="https://travis-ci.org/">Travis-ci官网</a> ，点击Sign In</li><li>在官网build<code>用户名.github.io</code>项目<br>点击这里的“+”号<br><img src="/resource/img/ci/T_GithubPages_2.png" alt="img"><br>找到或搜索我们的项目<br><img src="/resource/img/ci/T_GithubPages_3.png" alt="img"><br>完成之后可以在首页见到该项目<br><img src="/resource/img/ci/T_GithubPages_4.png" alt="img"></li><li>进入该项目，点击右侧的<code>More options</code>选择<code>Settings</code><br>在<code>Environment Variables</code>下 add 一个名为<code>Github_Token</code>的变量<br><img src="/resource/img/ci/T_GithubPages_5.png" alt="img"></li></ol><p>4.提交代码到Github</p><ol><li><p>在本地项目的根目录下新建一个<code>.travis.yml</code>文件</p><details>  <summary>点击展开</summary><pre><code class="hljs yml"><span class="hljs-comment"># 设置语言</span><span class="hljs-attr">language:</span> <span class="hljs-string">node_js</span><span class="hljs-comment"># 设置相应的版本</span><span class="hljs-attr">node_js:</span> <span class="hljs-string">stable</span><span class="hljs-attr">cache:</span>  <span class="hljs-attr">apt:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">directories:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">node_modules</span> <span class="hljs-comment"># 缓存不经常更改的内容</span><span class="hljs-comment"># 更改时区</span><span class="hljs-attr">before_install:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">export</span> <span class="hljs-string">TZ=&#x27;Asia/Shanghai&#x27;</span><span class="hljs-comment"># 安装hexo及插件</span><span class="hljs-attr">install:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><span class="hljs-comment"># 下拉代码后执行的操作</span><span class="hljs-attr">script:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span> <span class="hljs-comment"># 清除</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">g</span> <span class="hljs-comment"># 生成</span><span class="hljs-attr">after_script:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">./public</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">init</span>  <span class="hljs-comment"># 修改github的用户名</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">user.name</span> <span class="hljs-string">&quot;soldiergit&quot;</span>  <span class="hljs-comment"># 修改email</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">user.email</span> <span class="hljs-string">&quot;soldier_wyyx@163.com&quot;</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">add</span> <span class="hljs-string">.</span>  <span class="hljs-comment"># 提交记录包含时间 跟上面更改时区配合</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">commit</span> <span class="hljs-string">-m</span> <span class="hljs-string">&quot;Travis CI Auto Builder at `date +&quot;</span><span class="hljs-string">%Y-%m-%d</span> <span class="hljs-string">%H:%M&quot;`&quot;</span>  <span class="hljs-comment"># Travis_Token是在Travis官网中配置环境变量的名称（more options 选择 setting添加的值）</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">--force</span> <span class="hljs-string">--quiet</span> <span class="hljs-string">&quot;https://$&#123;Github_Token&#125;@$&#123;GH_REF&#125;&quot;</span> <span class="hljs-string">master:master</span><span class="hljs-comment"># 只监测resource分支，resource是我存放源码的分支的名称，可根据自己情况设置</span><span class="hljs-attr">branches:</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">resource</span><span class="hljs-comment"># 配置常量</span><span class="hljs-attr">env:</span>  <span class="hljs-attr">global:</span>    <span class="hljs-comment"># 设置GH_REF，注意更改yourname及末尾加上.git</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">GH_REF:</span> <span class="hljs-string">github.com/soldiergit/soldiergit.github.io.git</span><span class="hljs-comment"># 配置通知（电子邮件、IRC、campfire等）</span><span class="hljs-comment"># https://docs.travis-ci.com/user/notifications/</span><span class="hljs-attr">notifications:</span>  <span class="hljs-attr">email:</span>    <span class="hljs-bullet">-</span> <span class="hljs-number">583403411</span><span class="hljs-string">@qq.com</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">soldier_wyyx@163.com</span>  <span class="hljs-attr">on_success:</span> <span class="hljs-string">change</span>  <span class="hljs-attr">on_failure:</span> <span class="hljs-string">always</span></code></pre> </details><p><img src="/resource/img/ci/T_GithubPages_6.png" alt="img"></p></li><li><p>将所有代码提交到Github的<code>resource</code>上即可<br><img src="/resource/img/ci/T_GithubPages_7.png" alt="img"><br><img src="/resource/img/ci/T_GithubPages_8.png" alt="img"><br><img src="/resource/img/ci/T_GithubPages_9.png" alt="img"></p></li></ol><h2 id="4-实现在线写作"><a href="#4-实现在线写作" class="headerlink" title="4.实现在线写作"></a>4.实现在线写作</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p><img src="/resource/img/ci/silu.png" alt="img"></p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li><p>获取 <a href="https://travis-ci.org/account/preferences">Travis-ci</a> 的访问 token<br> <img src="/resource/img/ci/travisci_token.png" alt="img"></p></li><li><p>编写触发 Travis-ci 的 Serverless 函数：注册<a href="https://cloud.tencent.com/">腾讯云</a> 并边<a href="https://console.cloud.tencent.com/scf/list">创建一个云函数</a><br> <img src="/resource/img/ci/serverless.png" alt="img"></p> <pre><code class="hljs py"><span class="hljs-comment"># -*- coding: utf8 -*-</span><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> json<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main_handler</span>(<span class="hljs-params">event, context</span>):</span>    r = requests.post(<span class="hljs-string">&quot;https://api.travis-ci.org/repo/soldiergit%2Fsoldiergit.github.io/requests&quot;</span>,    json = &#123;<span class="hljs-string">&quot;request&quot;</span>: &#123;<span class="hljs-string">&quot;branch&quot;</span>: <span class="hljs-string">&quot;src&quot;</span>&#125;&#125;,    headers = &#123;<span class="hljs-string">&quot;User-Agent&quot;</span>:<span class="hljs-string">&#x27;curl/7.52.1&#x27;</span>,              <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,              <span class="hljs-string">&#x27;Travis-API-Version&#x27;</span>: <span class="hljs-string">&#x27;3&#x27;</span>,              <span class="hljs-string">&#x27;Accept&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,              <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;travis-ci的token&#x27;</span>&#125;)    <span class="hljs-keyword">if</span> r.status_code == <span class="hljs-number">204</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This&#x27;s OK!&quot;</span>     <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> r.status_code</code></pre></li><li><p>创建触发器，将函数发布，复制该函数的访问地址<br> <img src="/resource/img/ci/trigger.png" alt="img"></p></li><li><p>配置语雀</p><ol><li>注册语雀账号，创建一个<code>文档知识库</code>，专门为GithubPages服务</li><li>配置语雀 webhook，将上一步复制的函数访问地址贴到 URL 那栏<br> <img src="/resource/img/ci/yuque1.png" alt="img"></li><li>创建一个<a href="https://www.yuque.com/settings/tokens">语雀Token</a>，勾选<code>读取</code></li></ol></li><li><p>项目配置</p><ol><li><p>安装插件</p><pre><code class="hljs shell">npm i -g yuque-hexo</code></pre></li><li><p>配置 package.json<br> <img src="/resource/img/ci/yuque2.png" alt="img"></p> <pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;hexo-site&quot;</span>,  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.0.0&quot;</span>,  <span class="hljs-attr">&quot;private&quot;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;    <span class="hljs-attr">&quot;sync&quot;</span>: <span class="hljs-string">&quot;yuque-hexo sync&quot;</span>,    <span class="hljs-attr">&quot;clean:yuque&quot;</span>: <span class="hljs-string">&quot;yuque-hexo clean&quot;</span>,    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;hexo generate&quot;</span>,    <span class="hljs-attr">&quot;clean&quot;</span>: <span class="hljs-string">&quot;hexo clean&quot;</span>,    <span class="hljs-attr">&quot;deploy&quot;</span>: <span class="hljs-string">&quot;hexo deploy&quot;</span>,    <span class="hljs-attr">&quot;server&quot;</span>: <span class="hljs-string">&quot;hexo server&quot;</span>  &#125;,  <span class="hljs-attr">&quot;hexo&quot;</span>: &#123;    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;5.2.0&quot;</span>  &#125;,  <span class="hljs-attr">&quot;yuqueConfig&quot;</span>: &#123;  <span class="hljs-attr">&quot;postPath&quot;</span>: <span class="hljs-string">&quot;source/_posts/yuque&quot;</span>,  <span class="hljs-attr">&quot;cachePath&quot;</span>: <span class="hljs-string">&quot;yuque.json&quot;</span>,  <span class="hljs-attr">&quot;mdNameFormat&quot;</span>: <span class="hljs-string">&quot;slug&quot;</span>,  <span class="hljs-attr">&quot;adapter&quot;</span>: <span class="hljs-string">&quot;hexo&quot;</span>,  <span class="hljs-attr">&quot;concurrency&quot;</span>: <span class="hljs-number">5</span>,  <span class="hljs-attr">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;https://www.yuque.com/api/v2&quot;</span>,  <span class="hljs-attr">&quot;login&quot;</span>: <span class="hljs-string">&quot;soldier_yuque&quot;</span>,  <span class="hljs-attr">&quot;repo&quot;</span>: <span class="hljs-string">&quot;blog&quot;</span>,  <span class="hljs-attr">&quot;token&quot;</span>: <span class="hljs-string">&quot;语雀的token&quot;</span>,  <span class="hljs-attr">&quot;onlyPublished&quot;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">&quot;onlyPublic&quot;</span>: <span class="hljs-literal">true</span>&#125;,  <span class="hljs-attr">&quot;dependencies&quot;</span>: &#123;    <span class="hljs-attr">&quot;hexo&quot;</span>: <span class="hljs-string">&quot;^5.0.0&quot;</span>,    <span class="hljs-attr">&quot;hexo-deployer-git&quot;</span>: <span class="hljs-string">&quot;^2.1.0&quot;</span>,    <span class="hljs-attr">&quot;hexo-generator-archive&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span>,    <span class="hljs-attr">&quot;hexo-generator-category&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span>,    <span class="hljs-attr">&quot;hexo-generator-index&quot;</span>: <span class="hljs-string">&quot;^2.0.0&quot;</span>,    <span class="hljs-attr">&quot;hexo-generator-tag&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span>,    <span class="hljs-attr">&quot;hexo-renderer-ejs&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span>,    <span class="hljs-attr">&quot;hexo-renderer-marked&quot;</span>: <span class="hljs-string">&quot;^3.0.0&quot;</span>,    <span class="hljs-attr">&quot;hexo-renderer-stylus&quot;</span>: <span class="hljs-string">&quot;^2.0.0&quot;</span>,    <span class="hljs-attr">&quot;hexo-server&quot;</span>: <span class="hljs-string">&quot;^2.0.0&quot;</span>,    <span class="hljs-attr">&quot;hexo-theme-fluid&quot;</span>: <span class="hljs-string">&quot;^1.8.4&quot;</span>,    <span class="hljs-attr">&quot;yuque-hexo&quot;</span>: <span class="hljs-string">&quot;^1.7.0&quot;</span>  &#125;&#125;</code></pre></li><li><p>配置 <code>.travis.yml</code></p> <details>     <summary>点击展开</summary> <pre><code class="hljs yml"><span class="hljs-comment"># 设置语言</span><span class="hljs-attr">language:</span> <span class="hljs-string">node_js</span><span class="hljs-comment"># 设置相应的版本（必须12以上）</span><span class="hljs-attr">node_js:</span>   <span class="hljs-bullet">-</span> <span class="hljs-number">15</span><span class="hljs-attr">cache:</span>  <span class="hljs-attr">apt:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">directories:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">node_modules</span> <span class="hljs-comment"># 缓存不经常更改的内容</span><span class="hljs-comment"># 更改时区</span><span class="hljs-attr">before_install:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">export</span> <span class="hljs-string">TZ=&#x27;Asia/Shanghai&#x27;</span><span class="hljs-comment"># 安装hexo及插件</span><span class="hljs-attr">install:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">hexo-cli</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">yuque-hexo</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><span class="hljs-comment"># 下拉代码后执行的操作</span><span class="hljs-attr">script:</span>  <span class="hljs-comment"># 同步语雀文章到本地</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">yuque-hexo</span> <span class="hljs-string">clean</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">yuque-hexo</span> <span class="hljs-string">sync</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span> <span class="hljs-comment"># 生成</span><span class="hljs-attr">after_script:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">./public</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">init</span>  <span class="hljs-comment"># 修改github的用户名</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">user.name</span> <span class="hljs-string">&quot;soldiergit&quot;</span>  <span class="hljs-comment"># 修改email</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">user.email</span> <span class="hljs-string">&quot;soldier_wyyx@163.com&quot;</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">add</span> <span class="hljs-string">.</span>  <span class="hljs-comment"># 提交记录包含时间 跟上面更改时区配合</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">commit</span> <span class="hljs-string">-m</span> <span class="hljs-string">&quot;Travis CI Auto Builder at `date +&quot;</span><span class="hljs-string">%Y-%m-%d</span> <span class="hljs-string">%H:%M&quot;`&quot;</span>  <span class="hljs-comment"># Travis_Token是在Travis官网中配置环境变量的名称（more options 选择 setting添加的值）</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">--force</span> <span class="hljs-string">--quiet</span> <span class="hljs-string">&quot;https://$&#123;Github_Token&#125;@$&#123;GH_REF&#125;&quot;</span> <span class="hljs-string">master:master</span>  <span class="hljs-comment"># 【2021.05.13】修改gitee的用户名</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">user.name</span> <span class="hljs-string">&quot;$&#123;Gitee_Username&#125;&quot;</span>  <span class="hljs-comment"># 【2021.05.13】也提交到码云</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">--force</span> <span class="hljs-string">--quiet</span> <span class="hljs-string">https://$&#123;Gitee_Username&#125;:$&#123;Gitee_Token&#125;@$&#123;GE_REF&#125;</span> <span class="hljs-string">master:master</span><span class="hljs-comment"># 只监测resource分支，resource是我存放源码的分支的名称，可根据自己情况设置</span><span class="hljs-attr">branches:</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">resource</span><span class="hljs-comment"># 配置常量</span><span class="hljs-attr">env:</span>  <span class="hljs-attr">global:</span>    <span class="hljs-comment"># 设置GH_REF，注意更改yourname及末尾加上.git</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">GH_REF:</span> <span class="hljs-string">github.com/soldiergit/soldiergit.github.io.git</span>    <span class="hljs-comment"># 【2021.05.13】码云的</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">GE_REF:</span> <span class="hljs-string">gitee.com/soldiergitee/soldiergitee.git</span><span class="hljs-comment"># 配置通知（电子邮件、IRC、campfire等）</span><span class="hljs-comment"># https://docs.travis-ci.com/user/notifications/</span><span class="hljs-attr">notifications:</span>  <span class="hljs-attr">email:</span>    <span class="hljs-bullet">-</span> <span class="hljs-number">583403411</span><span class="hljs-string">@qq.com</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">soldier_wyyx@163.com</span>  <span class="hljs-attr">on_success:</span> <span class="hljs-string">change</span>  <span class="hljs-attr">on_failure:</span> <span class="hljs-string">always</span></code></pre> </details></li></ol></li></ol><p>配置完成将其提交到你的 github 仓库。</p><p><font color=#FF000><strong>注意：</strong></font>语雀不要开启保存并发布，否则无法触发 webhook</p>]]></content>
    
    
    
    <tags>
      
      <tag>持续集成</tag>
      
      <tag>Travis-ci</tag>
      
      <tag>Hexo</tag>
      
      <tag>语雀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西安神州数码融信软件有限公司</title>
    <link href="/2020/12/15/workplace/DCITS/"/>
    <url>/2020/12/15/workplace/DCITS/</url>
    
    <content type="html"><![CDATA[<h2 id="公司介绍"><a href="#公司介绍" class="headerlink" title="公司介绍"></a>公司介绍</h2><p>张微微 05年 项目经理<br>神州数码控股有限公司<br>母公司：神州数码信息服务股份有限公司 简称：神州信息 关键字：使命、定位、战略 股票代码：000555.SZ<br>神州数码融信软件有限公司 金融SBU部门，百分之九十做的银行<br>在金融、政府、电信</p><p>分布式与微服务、前端服务、渠道营销、数据服务、业务处理、融合场景、运维管理、测试服务质量管控、人工智能、大数据、云管理、区块链、物联网、5G<br>拥有3个研发中心、5个交付中心、1个创新中心 5个研发基地：北京、上海、广州、深圳、西安</p><h2 id="第一章、Java基础知识"><a href="#第一章、Java基础知识" class="headerlink" title="第一章、Java基础知识"></a>第一章、Java基础知识</h2><h3 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1.类和对象"></a>1.类和对象</h3><h4 id="1-类的定义和声明"><a href="#1-类的定义和声明" class="headerlink" title="1)类的定义和声明"></a>1)类的定义和声明</h4><ul><li><strong>类的定义：</strong> 基于面向对象思想，现实生活中具有相同特性的对象的抽象就称为类。类由类声明和类体构成，类体又由变量和方法构成。</li><li><strong>类的声明：</strong> 访问说明符 class 类名 extends 超类名 implements 接口名</li><li><strong>类体：</strong><ul><li>成员变量：指类的一些属性。格式：访问说明符号 数据类型 变量名</li><li>成员方法：指类创建的对象能做什么</li><li>格式：访问说明符 数据类型 方法名（数据类型1 变量名1， 数据类型2 变量2）<ul><li>八大基本数据类型：int short float double long boolean chart byte</li></ul></li></ul></li></ul><h4 id="2-类的实例化"><a href="#2-类的实例化" class="headerlink" title="2)类的实例化"></a>2)类的实例化</h4><ul><li><strong>概念：</strong> 通过一个类创建一个对象，这个过程叫做实例化</li><li><strong>举例：</strong> Hero a = new Hero();</li></ul><h4 id="3-方法的重载"><a href="#3-方法的重载" class="headerlink" title="3)方法的重载"></a>3)方法的重载</h4><ul><li><strong>概念：</strong> 存在与同一个类中，指一个方法与已经存在的方法名称相同，但是参数类型、个数、顺序至少有一个不同；但是返回值不同，其它都相同不是重载</li><li><strong>作用：</strong> 使用同一个方法名，根据参数的不同，调用不同的方法，实现相似的操作</li></ul><h4 id="4-类的构造方法"><a href="#4-类的构造方法" class="headerlink" title="4)类的构造方法"></a>4)类的构造方法</h4><ul><li><strong>概念：</strong> 方法名和类名一样，包括大小写，没有返回类型的方法</li><li><strong>作用：</strong> 实现类的实例化，实例化一个对象的时候，必须调用构造方法</li></ul><h4 id="5-类的继承"><a href="#5-类的继承" class="headerlink" title="5)类的继承"></a>5)类的继承</h4><ul><li><strong>概念：</strong> 继承就是子类继承父类的特征和行为，使得子类对象具有父类的属性和方法</li><li><strong>作用：</strong> 子类可以继承父类的全部功能，可以增加新属性、新功能</li></ul><h4 id="6-方法的重写"><a href="#6-方法的重写" class="headerlink" title="6)方法的重写"></a>6)方法的重写</h4><ul><li><strong>概念：</strong> 子类可以继承父类的对象方法，在继承后，重复提供该方法，就叫做方法的重写，又叫覆盖override</li><li><strong>作用：</strong> 当父类的方法无法满足要求，需要子类具有特有的功能，就需要方法重写</li></ul><h4 id="7-方法的隐藏"><a href="#7-方法的隐藏" class="headerlink" title="7)方法的隐藏"></a>7)方法的隐藏</h4><ul><li><strong>概念：</strong> 方法的隐藏与重写类似，重写是子类覆盖父类的对象方法，隐藏就是子类覆盖父类的类方法</li><li><strong>作用：</strong> 当方法属于类是，子类通过方法的隐藏调用到子类的类方法</li></ul><h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h3><h4 id="1-接口的定义和声明"><a href="#1-接口的定义和声明" class="headerlink" title="1)接口的定义和声明"></a>1)接口的定义和声明</h4><ul><li><strong>定义：</strong> 接口帮助类扩展方法，接口与类不同在于；<ul><li>没有变量的声明，但可以定义变量；</li><li>只有方法的声明，没有方法的实现</li></ul></li><li><strong>声明：</strong> public interface 接口名 extends 接口列表</li></ul><h3 id="3-常用类和数据结构"><a href="#3-常用类和数据结构" class="headerlink" title="3.常用类和数据结构"></a>3.常用类和数据结构</h3><h4 id="1-数组"><a href="#1-数组" class="headerlink" title="1)数组"></a>1)数组</h4><ul><li><strong>概念：</strong> 数组是一个固定长度的，包含了相同类型数据的容器</li><li><strong>初始化：</strong> <code>int[] arr = new int[5];</code></li></ul><h4 id="2-Object类"><a href="#2-Object类" class="headerlink" title="2)Object类"></a>2)Object类</h4><ul><li><strong>Object类概念：</strong> Object类是所有类的父类，声明一个类的时候，默认是继承了Object类。如<code>public class Hero extends Object &#123;...&#125;</code></li><li><strong>toString方法：</strong> 返回当前对象的字符串表达，默认返回对象的类名+内存地址值</li><li><strong>equals方法：</strong> 用于判断两个对象的内容是否相同，默认比较的是地址，在实际使用中需要比较两个对象的内容是否一致，所以经常要重写equals方法</li></ul><h4 id="3-String类"><a href="#3-String类" class="headerlink" title="3)String类"></a>3)String类</h4><ul><li>length()方法：返回字符串长度；</li><li>trim()方法：返回字符串并删除任何前导和尾随控股；</li><li>String构造方法<ul><li>String(char[] value)：使用字符数组构造一个字符串；</li><li>String(String original):使用原字符串original的拷贝以构造一个新字符串；</li></ul></li><li>indexOf(String str)：返回str第一次出现的位置；</li><li>substring(int begin, int end)：返回下标begin到end-1的字符串；</li><li>equals(Object obj)：比较字符串的值是否与obj的字符串的相同，应使用常量或确定有值的对象来调用equals方法。</li></ul><h4 id="4-String、StringBuffer和StringBuilder使用比较"><a href="#4-String、StringBuffer和StringBuilder使用比较" class="headerlink" title="4)String、StringBuffer和StringBuilder使用比较"></a>4)String、StringBuffer和StringBuilder使用比较</h4><table><thead><tr><th align="center">名称</th><th align="center">特点</th><th align="center">使用场景</th></tr></thead><tbody><tr><td align="center">String</td><td align="center">①不可变字符序列，String一经初始化后内容不会改变了；<br/>②对String的操作实际上对其副本（原始拷贝）的操作，原本字符串一点都没有改变；<br/>③如果多次执行改变串内容操作，会导致大量副本字符串对象留在内存中，降低效率。</td><td align="center">固定的、不经常变化的字符串数据</td></tr><tr><td align="center">StringBuffer</td><td align="center">①可变字符序列，线程安全，但是效率低；<br/>②其是对原子符串本身操作，可以对字符串进行修改而不产生副本拷贝；<br/>③append方法用于追加字符串，类似于String的“+”。</td><td align="center">多线程环境下，需要经常变化的字符串</td></tr><tr><td align="center">StringBuilder</td><td align="center">①可变字符串序列，线程不安全，但是效率高；<br/>②使用方法与StringBuffer类型。</td><td align="center">单线程环境下，需要经常变化的字符串</td></tr></tbody></table><h4 id="5-包装类"><a href="#5-包装类" class="headerlink" title="5)包装类"></a>5)包装类</h4><ul><li>概念：在面向对象的操作中经常需要将基本数据转为对象，这个基本和基本数据类型对应的类统称为包装类（wrapper class）；</li><li>用途：<ul><li>作为和基本数据类型对应的类型存在，方便对象的操作和数组转换；</li><li>当业务方法的参数是Object时，不能传入基本数据类型，需要使用包装类，包装类型的初始值为null；</li></ul></li></ul><table><thead><tr><th align="center">基本数据类型</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td></tr><tr><td align="center">char</td><td align="center">Character</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr></tbody></table><h4 id="6-包装类的数值转换"><a href="#6-包装类的数值转换" class="headerlink" title="6)包装类的数值转换"></a>6)包装类的数值转换</h4><ul><li><p>基本数据类型-包装类：</p><ul><li>基本数据类型-》包装类：使用包装类的valueOf()方法，参数为对应的基本数据类型的值，返回一个包装类的对象；</li><li>包装类-》基本数据类型：使用包装类XXX的XXXValue()，如<code>Integer i1=new Integer(10); int i = i1.intValue();</code></li></ul></li><li><p>基本数据类型/包装类-字符串：</p><ul><li>基本数据类型-》字符串：可以使用基本数据类型+””，还可以使用String.valueOf(基本数据类型)方法；</li><li>包装类-》字符串：使用包装类的toString()方法；</li><li>字符串-》基本数据类型/包装类：调用包装类的parseXXX(String str)方法，如<code>int i = Integer.parseInt(&quot;10&quot;);</code></li></ul></li></ul><h4 id="7-容器类"><a href="#7-容器类" class="headerlink" title="7)容器类"></a>7)容器类</h4><table><thead><tr><th align="center">名称</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">Collection和Map</td><td align="center">①Collection是一个独立元素的序列，这些元素都服从一条或多条规则；<br/>②Map是一组成对的“键值对”对象，允许使用键来查找值。</td></tr><tr><td align="center">HashSet</td><td align="center">①集合元素不重复；<br/>②不保证集合中原始的顺序；<br/>③只能允许有一个null元素</td></tr><tr><td align="center">Vector</td><td align="center">①基于数组的数据结构，同步的，线程安全；<br/>②执行效率不如ArrayList</td></tr><tr><td align="center">ArrayList</td><td align="center">①基于数组的数据结构，不同步，线程不安全；<br/>②查找、修改元素效率高</td></tr><tr><td align="center">LinkedList</td><td align="center">①基于链表的数据结构，允许null元素；<br/>②增加、删除元素效率高</td></tr><tr><td align="center">HashMap</td><td align="center">①key值不能重复；<br/>②线程不安全。效率高；<br/>③null值可以作为key，且只能有一个</td></tr><tr><td align="center">Hashtable</td><td align="center">①key值不能重复；<br/>②线程安全，效率不如HashMap；<br/>③key和value都不能出现null</td></tr></tbody></table><h3 id="4-IO流"><a href="#4-IO流" class="headerlink" title="4.IO流"></a>4.IO流</h3><ul><li>概念：IO是实现输入和输出的基础，在Java中通过流的形式允许Java程序使用相同的方式来访问不同的输入和输出源；</li><li>体系：<ul><li>磁盘操作：File</li><li>字节操作：InputStream和OutputStream</li><li>字符操作：Reader和Writer</li><li>对象操作：Serializable</li><li>网络操作：Socket</li><li>新的输入/输出：NIO</li></ul></li><li>File对象：负责程序与文件之间的数据传输，在Java中文件被抽象为File类，可以表示文件和文件夹；</li><li>使用字节流读写文件：<ul><li>读：<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bitR</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/home/soldier/Downloads/test.txt&quot;</span>);    <span class="hljs-comment">//从文件中读取内容</span>    FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);    <span class="hljs-keyword">byte</span> b[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>) file.length()];    <span class="hljs-keyword">int</span> len = fileInputStream.read(b);<span class="hljs-comment">//读取后返回长度</span>    fileInputStream.close();    System.err.println(<span class="hljs-keyword">new</span> String(b));&#125;</code></pre></li><li>写：<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bitW</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/home/soldier/Downloads/test.txt&quot;</span>);    FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(file);    fileOutputStream.write(<span class="hljs-string">&quot;soldier is good！\n&quot;</span>.getBytes());<span class="hljs-comment">//可以指定编码</span>    fileOutputStream.close();&#125;</code></pre></li></ul></li><li>使用字符流读写文件：<ul><li>读：<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">charR</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;    FileReader fileReader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;/home/soldier/Downloads/test.txt&quot;</span>);    BufferedReader bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(fileReader);    String bString;    <span class="hljs-keyword">while</span> ((bString = bufferedReader.readLine())!=<span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//逐行读取</span>        System.out.println(bString);    &#125;    bufferedReader.close();&#125;</code></pre></li><li>写：<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">charW</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;    FileWriter fileWriter = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;/home/soldier/Downloads/test.txt&quot;</span>);    PrintWriter printWriter = <span class="hljs-keyword">new</span> PrintWriter(fileWriter);    printWriter.write(<span class="hljs-string">&quot;soldier is good！&quot;</span>);    printWriter.close();&#125;</code></pre></li></ul></li></ul><h3 id="5-Java的异常"><a href="#5-Java的异常" class="headerlink" title="5.Java的异常"></a>5.Java的异常</h3><ul><li><strong>概念：</strong> 指当程序中某些地方出错时创建的一种特殊的运行时错误对象，程序捕捉到这个异常后，可以编写相应的异常处理代码进行处理；</li><li><strong>分类：</strong> Throwable 可以用来表示任何可以作为异常抛出的类，分为两种：Error和Exception。其中Error用来表示JVM无法处理的错误，Exception分为两种：<ul><li>受检异常：需要用try…catch…语句捕获并进行处理，并且可以从异常中恢复；</li><li>非受检异常：是程序运行时错误，例如除0会引发 Arichmetic Exception，此时程序奔溃并无法恢复。</li></ul></li></ul><h2 id="第二章、SQL基础知识"><a href="#第二章、SQL基础知识" class="headerlink" title="第二章、SQL基础知识"></a>第二章、SQL基础知识</h2><h3 id="1-数据对象"><a href="#1-数据对象" class="headerlink" title="1.数据对象"></a>1.数据对象</h3><ol><li>数据库表：由行和列组成；</li><li>用户：所谓用户就是有权限访问数据库的人，同时需要自己登陆账号和密码；</li><li>索引：是指根据指定的数据库表列建立起来的顺序，达到快速访问数据的目的；</li><li>触发器：是一个用户定义SQL事务命令的集合，当对一个表进行插入、修改、删除时，这组命令就会自动执行；</li><li>视图：视图看上去跟表类似，但其实是一个虚拟的表，并不在数据库中真实存在。</li></ol><h3 id="2-数据库用户及权限"><a href="#2-数据库用户及权限" class="headerlink" title="2.数据库用户及权限"></a>2.数据库用户及权限</h3><h4 id="1-用户"><a href="#1-用户" class="headerlink" title="1)用户"></a>1)用户</h4><ol><li>创建用户：create user username@’host’ identified by ‘password’;</li><li>用户授权：grant 权限 on database.tables to username@’host’;</li><li>修改密码：alter user username@’host’ identified by ‘newPassword’;</li><li>删除用户：drop user username@’host’;</li></ol><h4 id="2-数据库权限"><a href="#2-数据库权限" class="headerlink" title="2)数据库权限"></a>2)数据库权限</h4><ol><li>三种系统权限：DBA、RESOURCE、CONNECT;</li><li>六种数据对象权限：ALL、DELETE、INSERT、ALTER、UPDATE、SELECT ON;</li><li>GRANT赋予权限：grant 权限1,权限2,… on username1,username2,…;</li><li>REMOVE收回权限：remove 权限1,权限2,… on username1,username2,…;</li></ol><h3 id="3-数据查询语句"><a href="#3-数据查询语句" class="headerlink" title="3.数据查询语句"></a>3.数据查询语句</h3><ol><li><strong>多表查询：</strong> 允许你在查询的from条件后面跟多个表，然后把表之间的关系用where进行连接；<pre><code class="hljs sql"><span class="hljs-keyword">select</span> a.stuname <span class="hljs-keyword">from</span> student a, course b <span class="hljs-keyword">where</span> a.stuid = b.stuid;</code></pre></li><li>外连接：多表查询的外连接技术，可以列出多表查询中其中一个表的全部记录；<pre><code class="hljs sql"><span class="hljs-comment"># 显示左表全部记录，右表匹配不上时用null</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student t1 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> course t2 <span class="hljs-keyword">on</span> a.stuid = b.stuid;<span class="hljs-comment"># 显示左表全部记录，右表匹配不上时用null</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student t1 <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> course t2 <span class="hljs-keyword">on</span> a.stuid = b.stuid;<span class="hljs-comment"># Oracle数据库支持full join，mysql不支持，可以使用左外连接+ union +右外连接实现</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student t1 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> course t2 <span class="hljs-keyword">on</span> a.stuid = b.stuid    <span class="hljs-keyword">union</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student t1 <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> course t2 <span class="hljs-keyword">on</span> a.stuid = b.stuid;</code></pre></li><li>嵌套查询：select查询语句里可以嵌入select查询语句；<pre><code class="hljs sql"><span class="hljs-comment"># 查询学生有几门课</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">name</span>, (<span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> course.stuid=student.stuid) <span class="hljs-keyword">as</span> courses <span class="hljs-keyword">from</span> student;</code></pre></li><li>子查询：将子查询或in或exists当成where条件的一部分；<pre><code class="hljs sql"><span class="hljs-comment"># 查询学生为soldier的学生</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> stuid <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> stuid <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">&#x27;soldier&#x27;</span>);<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">EXISTS</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">&#x27;soldier&#x27;</span>);</code></pre></li><li>查询排序：order by语句根据指定的列对结果集进行排序；<pre><code class="hljs sql"><span class="hljs-comment"># asc是升序、desc是降序，默认asc</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> student.name <span class="hljs-keyword">asc</span>;</code></pre></li><li>查询分组：SQL无法把正常的列和汇总函数结合在一起，这时需要group by子句；<pre><code class="hljs sql"><span class="hljs-comment"># 统计学生的课程数</span><span class="hljs-keyword">select</span> stuid, <span class="hljs-keyword">count</span>(courseid) <span class="hljs-keyword">from</span> course <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> stuid;</code></pre></li><li>优化查询语句的两种方法<br> 7.1 表的查询顺序：①from子句中的第一个表最先处理叫基础表，多表查询时应选择记录最少的表做基础表；②3个表连接查询时，应选择交叉表作为基础表；<br> 7.2 用exists替代in：因为exists是判断真假，二in是与之一一比较。</li></ol><h3 id="4-数据操作"><a href="#4-数据操作" class="headerlink" title="4.数据操作"></a>4.数据操作</h3><ol><li>插入<pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span>(colum1, colum2, ...) <span class="hljs-keyword">values</span> (value1, value2, ...);</code></pre></li><li>修改<pre><code class="hljs sql"><span class="hljs-keyword">update</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">set</span> colum1=value1, colum2=value2, ... <span class="hljs-keyword">where</span> 条件;</code></pre></li><li>删除<pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> 条件;</code></pre></li></ol><p><strong>注意：</strong> 以上语句操作完成后，必须加上事务处理结束的命令commit才能生效，如果想撤回可以使用rollback命令复原。</p><h3 id="5-数据表定义"><a href="#5-数据表定义" class="headerlink" title="5.数据表定义"></a>5.数据表定义</h3><ol><li>创建表<pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tablename (    <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>,    fullname varcher(<span class="hljs-number">20</span>));</code></pre></li><li>修改表<pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tablename <span class="hljs-keyword">add</span> sex <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>);</code></pre></li><li>删除表<pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> tablename;</code></pre></li></ol><h2 id="第三章、Linux常用命令"><a href="#第三章、Linux常用命令" class="headerlink" title="第三章、Linux常用命令"></a>第三章、Linux常用命令</h2><h3 id="1-ls-显示文件名"><a href="#1-ls-显示文件名" class="headerlink" title="1.ls 显示文件名"></a>1.ls 显示文件名</h3><p><strong>命令格式：</strong> <code>ls [option] file</code><br>option：</p><ul><li>-l 显示详细列表<ul><li>结果域1：文件类型和文件权限<ul><li>第一个字符表示文件类型(-表示普通文件、d表示目录…)；</li><li>后面9个字符以每三个划分，分别表示文件拥有者、文件所属组、其他用户的权限</li></ul></li><li>域2：文件连接数</li><li>域3：文件拥有者名字</li><li>域4：文件所属组名字</li><li>域5：文件长度</li><li>域6-8：最近修改时间</li><li>域9：文件名</li></ul></li><li>-a 显示所有文件，包括隐藏文件</li><li>-R 显示文件及所有子目录</li><li>-F 显示文件(文件名后跟*)和目录(后跟/)</li><li>-d 与l选项合用，显示目录名而非其内容</li></ul><h3 id="2-cd-目录转换"><a href="#2-cd-目录转换" class="headerlink" title="2.cd 目录转换"></a>2.cd 目录转换</h3><p>注意目录分隔符为‘/’，与dos想反<br><strong>命令格式：</strong> <code>cd dirname</code></p><h3 id="3-pwd-显示当前路径"><a href="#3-pwd-显示当前路径" class="headerlink" title="3.pwd 显示当前路径"></a>3.pwd 显示当前路径</h3><p><strong>命令格式：</strong> <code>pwd</code></p><h3 id="4-cat-显示文件内容"><a href="#4-cat-显示文件内容" class="headerlink" title="4.cat 显示文件内容"></a>4.cat 显示文件内容</h3><p><strong>命令格式：</strong> <code>cat filename</code></p><h3 id="5-more-以分页方式查看文件内容"><a href="#5-more-以分页方式查看文件内容" class="headerlink" title="5.more 以分页方式查看文件内容"></a>5.more 以分页方式查看文件内容</h3><p><strong>命令格式：</strong> <code>more filename</code></p><table><thead><tr><th align="center">快捷键</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Enter</td><td align="center">向下n行，需要定义，默认1行</td></tr><tr><td align="center">Ctrl+F或空格键</td><td align="center">向下滚动1屏</td></tr><tr><td align="center">Ctrl+B</td><td align="center">向上滚动1屏</td></tr><tr><td align="center">=</td><td align="center">输出当前行的符号</td></tr><tr><td align="center">q</td><td align="center">退出more</td></tr></tbody></table><h3 id="6-vi-创建-编辑文件"><a href="#6-vi-创建-编辑文件" class="headerlink" title="6.vi 创建/编辑文件"></a>6.vi 创建/编辑文件</h3><p><strong>命令格式：</strong> <code>vi filename</code></p><table><thead><tr><th align="center">快捷键</th><th align="center">含义</th><th align="center">快捷键</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Ctrl+F</td><td align="center">向文件尾翻1屏</td><td align="center">Ctrl+B</td><td align="center">向文件首翻1屏</td></tr><tr><td align="center">i</td><td align="center">在光标前插入文本</td><td align="center">I</td><td align="center">在当前行首插入文本</td></tr><tr><td align="center">a</td><td align="center">在光标后插入文本</td><td align="center">A</td><td align="center">在当前行尾插入文本</td></tr><tr><td align="center">:w</td><td align="center">保存</td><td align="center">:x或:wq</td><td align="center">保存并退出文件</td></tr><tr><td align="center">:q</td><td align="center">退出vi</td><td align="center">:q!</td><td align="center">不保存并退出文件</td></tr><tr><td align="center">x</td><td align="center">非编辑状态下删除一个字符</td><td align="center">dd</td><td align="center">非编辑状态下删除整行</td></tr><tr><td align="center">Esc</td><td align="center">退出编辑状态</td><td align="center">:set nu</td><td align="center">显示文件行号</td></tr><tr><td align="center">/</td><td align="center">搜索</td><td align="center">n</td><td align="center">搜索状态下查看下一个结果，N则是上一个</td></tr></tbody></table><h3 id="7-df-查看问价系统磁盘使用情况"><a href="#7-df-查看问价系统磁盘使用情况" class="headerlink" title="7.df 查看问价系统磁盘使用情况"></a>7.df 查看问价系统磁盘使用情况</h3><p><strong>命令格式：</strong> <code>df [option]</code><br>option：</p><ul><li>-k：按照千字节查看；</li><li>-m：按照兆字节查看；</li></ul><h3 id="8-chmod-改变文件权限"><a href="#8-chmod-改变文件权限" class="headerlink" title="8.chmod 改变文件权限"></a>8.chmod 改变文件权限</h3><p><strong>命令格式：</strong> <code>chmod [options] mode file</code><br>只能文件拥有者或特权用户才能使用该功能来改变文件权限。mode可以是数字形式或以who opcode permission形式表示；who是可选的，默认是a(所有用户)；只能选择一个opcode(操作码)；可指定多个mode，以逗号隔开。<br>options：</p><ul><li>-c：只输出被改变文件信息；</li><li>-R：可递归遍历子目录，把修改应用到目录下所有文件和目录；</li><li>who：u用户、g组、o其它、a所有用户(默认)；</li><li>opcode：+增加权限，-删除权限；</li><li>permission：r读、w写、x执行</li></ul><p>我们多用三位八进制数字的形式来表示权限，第一位指定文件拥有者的权限，第一位指定文件所属组的权限，第一位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限，如：</p><ul><li>3(2+1)：表示有写和执行权限</li><li>5(4+1)：表示读和执行权限</li><li>6(4+2)：表示有读写权限</li><li>7(4+2+1)：表示有全部权限</li></ul><p>例子：</p><ul><li><code>chmod u+x file</code>：给file的拥有者执行权限；</li><li><code>chmod 751 file</code>：给file的拥有者全部权限，给file所属组读和执行权限，给其它用户执行权限；</li></ul><h3 id="ps-显示当前进程状态"><a href="#ps-显示当前进程状态" class="headerlink" title="ps 显示当前进程状态"></a>ps 显示当前进程状态</h3><p><strong>命令格式：</strong> <code>ps [option]</code><br>例子：</p><ul><li><code>ps -u root</code>：显示root用户进程信息；</li><li><code>ps -ef</code>：显示全部进程，连带命令行；</li></ul><h3 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir 创建目录"></a>mkdir 创建目录</h3><p><strong>命令格式：</strong> <code>mkdir [-p] dirname</code><br>例子：</p><ul><li><code>mkdir dir1</code>：建立一个新目录dir1；</li><li><code>mkdir -p dir/subdir</code>：建立多级目录；</li></ul><h3 id="cp-文件复制"><a href="#cp-文件复制" class="headerlink" title="cp 文件复制"></a>cp 文件复制</h3><p><strong>命令格式：</strong> <code>cp [-r] source destination</code><br>例子：</p><ul><li><code>cp file1 file2</code>：复制file1为file2，不覆盖；</li><li><code>cp file1 dir/</code>：将file1复制到dir目录下；</li><li><code>cp /etc/profile .</code>：将etc下的profile复制到当前目录下；</li><li><code>cp -r /etc dir2</code>：复制整个目录，若dir2存在，则将etc目录复制到dir2目录下；若不存在，则新增dir2目录并将etc下的所有文件和目录复制到dir2目录下；</li></ul><h3 id="mv-文件移动"><a href="#mv-文件移动" class="headerlink" title="mv 文件移动"></a>mv 文件移动</h3><p><strong>命令格式：</strong> <code>mv source&#39; destination</code><br>例子：</p><ul><li><code>mv file1 file2</code>：将file1重命名为file2；</li><li><code>mv file1 dir</code>：将file1移动到dir目录下下；</li><li><code>mv dir1 dir2</code>：移动整个目录，若dir2存在，则将dir1目录移动到dir2目录下；若不存在，则新增dir2目录并将dir1下的所有文件和目录移动到dir2目录下，然后dir1消失，相当于重命名；</li></ul><h3 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm 删除文件"></a>rm 删除文件</h3><p><strong>命令格式：</strong> <code>rm [-r] file/dir</code> -f表示不用确认<br>例子：</p><ul><li><code>rm file1</code>：删除file1文件或file1空目录；</li><li><code>rm -r dir1</code>：删除dir1目录及其所有子目录和文件；</li><li><code>rm file?</code>：删除以file开头的、文件名个数为5的文件或空目录；</li><li><code>rm f*</code>：删除以f开头的文件或空目录；</li></ul><h3 id="find-文件查找"><a href="#find-文件查找" class="headerlink" title="find 文件查找"></a>find 文件查找</h3><p><strong>命令格式：</strong> <code>find dir -name filename</code><br>例子：</p><ul><li><code>find . -name hello</code>：寻找当前目录及子目录下叫hello的文档；</li><li><code>find . -name hello*</code>：寻找当前目录及子目录下以hello开头的文档；</li><li><code>find . -ctime +7</code>：寻找7天前创建的文档，-mtime表示修改，-7表示7天内，7表示等于7天；</li><li><code>find . -size +2000c</code>：与上个命令类似，找出当前目录下大小超过2000 bytes的文档；</li><li><code>find /tmp -user soldier</code>：查找在tmp目录下归属用户soldier的文档；</li></ul><h3 id="tar-归档命令"><a href="#tar-归档命令" class="headerlink" title="tar 归档命令"></a>tar 归档命令</h3><p><strong>命令格式：</strong> <code>tar [主选项+辅选项] 文件或目录</code><br>主选项：</p><ul><li>-c：新建一个压缩包；</li><li>-x：解压文件；</li><li>-t：查看压缩文件的内容；</li><li>-r：向压缩文件追加文件；</li><li>-u：更新原压缩包的文件；</li></ul><p>辅助选项：</p><ul><li>-z：是否同时具有gzip的属性？即是否需要用gzip压缩或解压？一般格式为xxx.tar.gz或xxx.tgz；</li><li>-v：显示操作工程；</li><li>-f：使用文档名，注意要在f之后立即接文档名，不能再加其它参数；</li></ul><p>例子：</p><ul><li><code>tar -cvf 123.tar 111 222</code>：将111和222压缩成123.tar；</li><li><code>tar -zcvf 123.tar.gz 111 222</code>：使用gzip将111和222压缩成123.tar.gz；</li><li><code>tar -tvf 123.tar</code>：查看123.tar中的文件；</li><li><code>tar -xvf 123.tar</code>：解压123.tar；</li><li><code>tar -zxvf 123.tar.gz</code>：使用gzip解压123.tar.gz；</li><li><code>tar -rvf 123.tar 333</code>：将333追加到123.tar中；</li></ul><h2 id="第四章、会计财务知识"><a href="#第四章、会计财务知识" class="headerlink" title="第四章、会计财务知识"></a>第四章、会计财务知识</h2><p>会计是基于人类生产活动和对生产活动进行记录的需要而产生的：</p><ul><li>古代会计：主要表现为官厅会计，会计匆匆也人员多为各级官厅、衙门服务；</li><li>近代会计：又称为企业会计，其标志是十四、五世纪复式记账体系的形成；</li><li>现代会计：又称为预测、决策会计，其标志是二十世纪二十年代以来在成本会计的基础上形成管理会计的内容和体系；</li></ul><p>会计的职能</p><ul><li>核算职能：输入（提供定量描述经济过程及其结果的数据信息）、转换（记账算法，整理分类汇总分析提炼输入的原始数据，转换为财务信息）、输出（通过财务报表提供系统的决策有用的信息），特点：<ul><li>以货币为主要计量单位；</li><li>反映过去发生的经济事项；</li><li>完整性，连续性，系统性；</li></ul></li><li>监督职能：货币监督；事前监督、事中监督和事后监督；内部监督和外部监督</li></ul><h3 id="为什么学习会计？"><a href="#为什么学习会计？" class="headerlink" title="为什么学习会计？"></a>为什么学习会计？</h3><p>经济发展需要：经济越发展，会计越重要、业务需求；<br>公司的业务对象为银行，即业务需求，需要了解一些会计知识，便于业务沟通，以及产品的开发。</p><h3 id="会计的三大问题-重点"><a href="#会计的三大问题-重点" class="headerlink" title="会计的三大问题(重点)"></a>会计的三大问题(重点)</h3><h4 id="1-为什么要提供会计信息？"><a href="#1-为什么要提供会计信息？" class="headerlink" title="1.为什么要提供会计信息？"></a>1.为什么要提供会计信息？</h4><ol><li>所有者和经营管理者分离；</li><li>反映和监督；</li><li>分析和决策；</li><li>企业做大必须的方法论、管理工具；</li></ol><h4 id="2-向谁提供会计信息？"><a href="#2-向谁提供会计信息？" class="headerlink" title="2.向谁提供会计信息？"></a>2.向谁提供会计信息？</h4><ol><li>经营者：总经理及相关经营管理人员；</li><li>所有者：投资人；</li><li>债权人：银行等向企业贷款的机构；</li><li>监督机构：税务部门及行业监督机构；</li><li>其它：社会经济学者、国家宏观调控者；</li></ol><h4 id="3-提供什么信息？"><a href="#3-提供什么信息？" class="headerlink" title="3.提供什么信息？"></a>3.提供什么信息？</h4><ol><li>详细记录每一个经济活动——过程原始凭证；</li><li>统计所有者经济活动记录出具体财务报表；</li><li>同行业横向比较，大环境；行业前景分析报告；</li><li>本公司不同会计期间纵向比较；自身发展状况和趋势分析报告；</li><li>公司自身的财务状况分析报告；</li></ol><h3 id="会计对象"><a href="#会计对象" class="headerlink" title="会计对象"></a>会计对象</h3><ul><li>静态形式对象：资金（财务状况）；</li><li>动态形式对象：资金运动（经营过程）；</li></ul><h3 id="会计四前提-重点"><a href="#会计四前提-重点" class="headerlink" title="会计四前提(重点)"></a>会计四前提(重点)</h3><ol><li><font color=#FF000>会计主体</font><br> 含义：是会计工作为其服务的特定单位或组织；<br> 特点：界定了不同的会计主体其会核算的空间范围；<br> 目的：解决了为谁核算的问题解决；</li><li><font color=#FF000>持续经营</font><br> 含义：是指会计主体的生产经营活动在可预见的将来将延续下去，不会进行清算；<br> 特点：时间范围；<br> 目的：它为会计要素的确认提供了理论依据；</li><li><font color=#FF000>会计期间</font><br> 含义：是指将会计主体持续不断的经济活动分割为一定的期间；<br> 内容：可按时间人为分为月、季、半年、年度等；</li><li><font color=#FF000>货币计量</font><br> 含义：是指会计主体在会计核算过程中采用货币作为计量单位，记录、反映会计主体的经营情况；<br> 要求：确定一种记账的本位币；业务收支以外币作为计量单位的，编制报表时，应折算为本位币；</li></ol><p><font color=#FF000><strong>权责发生制</strong></font>：是指以收入的权利和支出的业务是否属于本期作为标准来确认收入和费用的一种记账基础；（更能调动员工积极性，类似于销售）<br><font color=#FF000><strong>收付实现制</strong></font>：是以款项是否实际收到和付出为标准来确认收入和费用的一种记账基础；（类似于教师等为人民服务的）</p><h3 id="会计六大要素-重点"><a href="#会计六大要素-重点" class="headerlink" title="会计六大要素(重点)"></a>会计六大要素(重点)</h3><p>利润表要素：反应企业的经营成果，表现资金显著变动的状态；<br>资产负债表要素：反映企业的财务状况，表现资金相对静止的状态；<br>分为两种：</p><ol><li>静态要素： 资产（预期给公司带来收益的一切资源）、负债、所有者权益</li><li>动态要素： 收入、费用、利润<ul><li>资产+费用 = 负债+所有者权益+收入</li><li>资产 = 负债+所有者权益+利润</li></ul></li></ol><h4 id="1-资产"><a href="#1-资产" class="headerlink" title="1.资产"></a>1.资产</h4><p>1.<font color=#FF000>流动资产</font>：预计在一个正常营业周期中变现、出售或耗用；主要为交易目的而持有；预计在资产负债起一年内（含一年）变现等；（包含：库存现金、银行存款、交易性金融资产、应收及预付款项和存货等）<br>2.<font color=#FF000>非流动资产</font>：持有一年以上或超过一年的在一个营业周期以上才能实现；（包含：长期投资、固定资产、无形资产和其他资产）</p><table><thead><tr><th align="center">一年的变化</th></tr></thead><tbody><tr><td align="center">资产 = 负债 + 所有者权益（年初）</td></tr><tr><td align="center">&#8595;</td></tr><tr><td align="center">资产 + 费用 = 负债 + 所有者权益 + 收入（发生过程）</td></tr><tr><td align="center">&#8595;</td></tr><tr><td align="center">资产 = 负债 + 所有者权益 + 收入 - 费用（结转过程）</td></tr><tr><td align="center">&#8595;</td></tr><tr><td align="center">资产 = 负债 + 所有者权益 + 利润（年末）</td></tr><tr><td align="center">&#8595;</td></tr><tr><td align="center">资产 = 负债 + 所有者权益（下一年年初）</td></tr></tbody></table><h4 id="2-负债"><a href="#2-负债" class="headerlink" title="2.负债"></a>2.负债</h4><p>1.<font color=#FF000>流动负债</font>：将在一年或超过一年的一个营业周期以内偿还的债务；（短期借款、应付票据、应付账款和应交税费等）<br>2.<font color=#FF000>非流动负债</font>：将在一年或超过一年的一个营业周期以上偿还的债务；（长期负债、应付债券和长期应付款等）</p><h4 id="3-所有者权益"><a href="#3-所有者权益" class="headerlink" title="3.所有者权益"></a>3.所有者权益</h4><p>1.<font color=#FF000>实收资本（股本）</font>：企业的注册资本<br>2.<font color=#FF000>资本公积</font>：除注册资本外的资本：资本（股本）溢价、接受捐赠的资本、拨款转入、外币资本折算差额<br>3.<font color=#FF000>盈利公积</font>：从税后利润中提取的资金<br>4.<font color=#FF000>未分配利润</font>：留待以后分配的利润</p><h4 id="4-收入"><a href="#4-收入" class="headerlink" title="4.收入"></a>4.收入</h4><p>公司资产增加，利益增加（营业外收入、主营业务收入、其它业务收入）</p><h4 id="5-费用"><a href="#5-费用" class="headerlink" title="5.费用"></a>5.费用</h4><p>企业在经营过程中产生的耗费（营业外支出、生产费用、经营期间费用）</p><h4 id="6-利润"><a href="#6-利润" class="headerlink" title="6.利润"></a>6.利润</h4><p>利润 = 收入-费用，企业收入扣除产品成本和税金</p><h3 id="会计等式"><a href="#会计等式" class="headerlink" title="会计等式"></a>会计等式</h3><ol><li>作用：是复式记账法的理论基础，也是编制资产负债表的依据</li><li>当经济业务发生引起等式两边会计要素的变化<br> 涉及到等式一边时，一增一减<br> 涉及到等式两边时，同增同减</li></ol><table><thead><tr><th align="center">会计等式</th></tr></thead><tbody><tr><td align="center">资产 = 负债+所有者权益</td></tr><tr><td align="center">资产 = 负债+所有者权益+利润（收入-费用）</td></tr><tr><td align="center">资产+费用 = 负债+所有者权益+收入</br>利润 = 收入-费用</td></tr></tbody></table><p>为什么资产 = 负债？<br>    是同一事物的不同角度来描述，资产是从使用者的角度，负债是从归还者的角度描述</p><h3 id="会计方法"><a href="#会计方法" class="headerlink" title="会计方法"></a>会计方法</h3><p>基本方法：</p><ol><li>设置账户；</li><li>复式记账；</li><li>填制和审核凭证；</li><li>登记账簿；</li><li>成本计算；</li><li>财产清查；</li><li>编制会计报表</li></ol><h3 id="复式记账法（重点）"><a href="#复式记账法（重点）" class="headerlink" title="复式记账法（重点）"></a>复式记账法（重点）</h3><h4 id="一、记账方法"><a href="#一、记账方法" class="headerlink" title="一、记账方法"></a>一、记账方法</h4><ol><li>概念：将经济业务在会计账户中进行登记的方法。</li><li>分类：<ol><li>单式记账法：对于发生每一项经济业务只在一个账户中进行登记的方法；</li><li>复式记账法：对于发生的每笔经济业务，都在两个或两个以上相互联系的账户中进行登记的方法。</li><li>两者相比：复式记账法可以全面了解经济业务的发生过程，可以进行试算平衡。</li></ol></li></ol><h4 id="二、借贷记账法"><a href="#二、借贷记账法" class="headerlink" title="二、借贷记账法"></a>二、借贷记账法</h4><ol><li>定义：借贷记账法是以“借”和“贷”为记账符号，把发生的经济业务所引起会计要素的增减变动，以相等的金额，同时在两个或两个以上的会计账户中。相互联系进行登记的一种复式的记账方法；</li><li>意义：是世界通用的记账方法，我国法定的记账方法；</li><li>理论依据：<ol><li>资产 = 负债 + 所有者权益 = 负债 + （所有者权益 + 利润） = 负债 + （所有者权益 + 收入 - 费用）；</li><li>资产 + 费用（成本） = 负债 + 所有者权益 + 收入；</li></ol></li><li>记账符号：<ul><li>记账符号：会计核算中所采用的表示对象增减变化的记账标记；</li><li>以“借”和“贷”为记账符号；</li><li>借贷记账法下，账户左方为借方，右方为贷方，用来反映资产或权益的增减变化；</li><li>具体含义：在资产（成本、费用）类账户中，“借”表示增加（借+），“贷”表示减少（贷-）</li><li>“借”和“贷”作为记账符号，已失去了原本的字面涵义，不再表示信用关系；</li><li>快速口诀：<ul><li>等号左边是资产性质，等号右边的是负债性质；</li><li>资产性质的增加或负债性质的减少记<code>借</code>；</li><li>资产性质的减少或负债性质的增加记<code>贷</code>；</li></ul></li></ul></li><li>记账规则：“有借必有贷，借贷比相等”<ol><li>对每一笔业务必须同时计入两个或两个以上的账户，而且其中一个计入借方，另一个计入贷方，决不能全计入借或贷方，即“有借必有贷”；</li><li>登记时，计入借方账户的金额必须与计入贷方账户的金额相等，即“借贷必相等”；</li></ol></li></ol><h4 id="三、复式记账法步骤"><a href="#三、复式记账法步骤" class="headerlink" title="三、复式记账法步骤"></a>三、复式记账法步骤</h4><p>复式记账法：当一个经济活动的发生影响到两个及其以上的科目，把他描述清楚的记账方法叫复式记账法<br>步骤：</p><ol><li>确定是否要记账？</li><li>确认关联哪几个科目？</li><li>确认科目的性质；</li><li>确认发生额对金额的影响？</li><li>确认科目的借贷方向？确定是贷方还是借方</li><li>写分录（一个会计分录只能有一个主体）</li></ol><h4 id="总结（重点-）"><a href="#总结（重点-）" class="headerlink" title="总结（重点**）"></a>总结（重点**）</h4><ol><li>会计等式左边是<code>资产</code>，右边是<code>负债</code>；</li><li>资产性质的增加或负债性质的减少记<code>借</code>；</li><li>资产性质的减少或负债性质的增加记<code>贷</code>；</li><li>应收是<code>资产</code> = 实付（以此类推应付、实收、实付）</li><li><code>经常出现的会计账户</code>（科目）：现金、银行账户、应收</li></ol><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="1、从银行提取现在6000元备用"><a href="#1、从银行提取现在6000元备用" class="headerlink" title="1、从银行提取现在6000元备用"></a>1、从银行提取现在6000元备用</h4><h5 id="以自己为会计主体"><a href="#以自己为会计主体" class="headerlink" title="以自己为会计主体"></a>以自己为会计主体</h5><p>我自己现在的现金和我在银行的存款</p><table><thead><tr><th align="center">步骤</th><th align="center">会计账户1</th><th align="center">会计账户2</th></tr></thead><tbody><tr><td align="center">（1）分析业务中涉及到的<font color=#FF000>会计账户</font></td><td align="center">现金</td><td align="center">银行存款</td></tr><tr><td align="center"></td><td align="center">&#8595;</td><td align="center">&#8595;</td></tr><tr><td align="center">（2）判断会计账户的<font color=#FF000>类型和增减</font></td><td align="center">资产+</td><td align="center">资产-</td></tr><tr><td align="center"></td><td align="center">&#8595;</td><td align="center">&#8595;</td></tr><tr><td align="center">（3）确认会计账户的<font color=#FF000>结构和记账方向</font></td><td align="center">借方</td><td align="center">贷方</td></tr><tr><td align="center"></td><td align="center">&#8595;</td><td align="center">&#8595;</td></tr><tr><td align="center">（4）记录账户的<font color=#FF000>增减变化及金额</font></td><td align="center">借：现金6000</br>(资产性质的增加)</td><td align="center">贷：银行存款6000</br>(资产性质的减少)</td></tr></tbody></table><h5 id="以银行为主体时"><a href="#以银行为主体时" class="headerlink" title="以银行为主体时"></a>以银行为主体时</h5><p>银行账户减少6000，银行欠我的钱和银行的现金都减少了</p><table><thead><tr><th align="center">会计账户1</th><th align="center">会计账户2</th></tr></thead><tbody><tr><td align="center">应付</td><td align="center">现金</td></tr><tr><td align="center">&#8595;</td><td align="center">&#8595;</td></tr><tr><td align="center">负债-</td><td align="center">资产-</td></tr><tr><td align="center">&#8595;</td><td align="center">&#8595;</td></tr><tr><td align="center">借方</td><td align="center">贷方</td></tr><tr><td align="center">&#8595;</td><td align="center">&#8595;</td></tr><tr><td align="center">借：应付6000</br>(负债性质的减少)</td><td align="center">贷：现金6000</br>(资产性质的减少)</td></tr></tbody></table><h4 id="2、A公司卖掉矿泉水一瓶收入3元"><a href="#2、A公司卖掉矿泉水一瓶收入3元" class="headerlink" title="2、A公司卖掉矿泉水一瓶收入3元"></a>2、A公司卖掉矿泉水一瓶收入3元</h4><h5 id="以公司为主体"><a href="#以公司为主体" class="headerlink" title="以公司为主体"></a>以公司为主体</h5><p>借：现金3元（资产性质增加）    贷：矿泉水3元（资产性质减少）</p><h4 id="3、A公司从外购进矿泉水一瓶花费2元"><a href="#3、A公司从外购进矿泉水一瓶花费2元" class="headerlink" title="3、A公司从外购进矿泉水一瓶花费2元"></a>3、A公司从外购进矿泉水一瓶花费2元</h4><h5 id="以公司为主体-1"><a href="#以公司为主体-1" class="headerlink" title="以公司为主体"></a>以公司为主体</h5><p>借：矿泉水2元（资产性质增加）    贷：现金2元（资产性质减少）</p><h4 id="4、A公司员工小张向公司借款500元用于差旅费"><a href="#4、A公司员工小张向公司借款500元用于差旅费" class="headerlink" title="4、A公司员工小张向公司借款500元用于差旅费"></a>4、A公司员工小张向公司借款500元用于差旅费</h4><h5 id="以小张为主体"><a href="#以小张为主体" class="headerlink" title="以小张为主体"></a>以小张为主体</h5><p>借：现金500元（资产性质增加）    贷：负债500元（负债性质增加）</p><h4 id="5、A公司员工小王在办公场所捡到100元"><a href="#5、A公司员工小王在办公场所捡到100元" class="headerlink" title="5、A公司员工小王在办公场所捡到100元"></a>5、A公司员工小王在办公场所捡到100元</h4><h5 id="以小王为主体"><a href="#以小王为主体" class="headerlink" title="以小王为主体"></a>以小王为主体</h5><p>借：现金100元（资产性质增加）    贷：非营业收入（负债性质增加）</p><h2 id="第五章、银行总体介绍"><a href="#第五章、银行总体介绍" class="headerlink" title="第五章、银行总体介绍"></a>第五章、银行总体介绍</h2><h3 id="银行的分类"><a href="#银行的分类" class="headerlink" title="银行的分类"></a>银行的分类</h3><p><code>国有商业银行</code>：中国工商银行、中国银行、中国农业银行、中国建设银行、交通银行、邮政储蓄；<br><code>政策性银行</code>：国家开发银行、中国进出口银行、中国农业发展银行；<br><code>股份制商业银行</code>：招商银行、中信银行、兴业银行、光大银行、民生银行…；<br><code>地方性商业银行</code>：①城市商业银行(北京、上海、天津银行…)，②村镇银行、农村资金互助银行(北京昌平赵峰村镇银行…)，③农村金融机构(信用社[乡]、农合行[县]、农商行[市]广西农村信用社…)；<br><code>外资银行</code>：汇丰银行、东亚银行…<br><code>新生代银行</code>：民营银行、互联网银行、直销银行；</p><h3 id="人民银行和商业银行的区别"><a href="#人民银行和商业银行的区别" class="headerlink" title="人民银行和商业银行的区别"></a>人民银行和商业银行的区别</h3><p><strong>中国人民银行</strong>，通俗的说它有两个特点：一是它是银行的银行，二是它是政府的银行，中国人民银行是金融货币管理机关，在行政上它是国家部级行政单位，是国务院的直属机构，管理商业银行，指定中国的货币和财政政策。<br><strong>商业银行</strong>是企业银行，是国家承认的社会金融机构，商业银行与一般工商企业一样，是以盈利为目的的企业。</p><h3 id="商业银行的四大职能"><a href="#商业银行的四大职能" class="headerlink" title="商业银行的四大职能"></a>商业银行的四大职能</h3><p><code>信用中介</code>是通过银行的负债业务，把社会上的各种闲散货币几种到银行里来，再通过资产业务，把它投入经济各部门。<br>信用中介是商业银行最基本、最能反映其经营活动特征的职能。</p><p><code>支付中介</code>是商业银行为客户收付与结算的职能。<br>银行通过转账结算，代替客户几种办理货币收付，对于减少流通中现金的使用，节约流通费用，加速资金周转具有重要的作用。</p><p><code>信用创造</code>：商业银行把负债作为货币进行流通，在支票流通和转账结算的基础上，贷款转化为存款，在存款不提或不完全提现时，增加了商业银行的资金来源，形成数倍于原始存款的派生存款。</p><p><code>金融服务</code>是指金融机构通过开展业务活动为客户提供包括融资投资、储蓄、信贷、结算、证券买卖、商业保险等多方面的服务。</p><h3 id="商业银行的业务分类"><a href="#商业银行的业务分类" class="headerlink" title="商业银行的业务分类"></a>商业银行的业务分类</h3><p>按<code>经营业务币种</code>的不同分为：本币业务和外币业务；<br>按<code>业务服务对象</code>的不同分为：公司业务、零售业务和同业业务；<br>按<code>业务资金来源</code>的不同分为：负债业务(存款)、资产业务(贷款)以及中间业务(第三方业务)；</p><h3 id="商业银行简介"><a href="#商业银行简介" class="headerlink" title="商业银行简介"></a>商业银行简介</h3><p><code>银行的经营三性原则</code>：是指银行在经营活动过程中必须兼顾安全性(经营管理的保证)、流动性(前提)和盈利性(目标)的原则，追求三者的相统一、相协调；</p><p><code>银行的利率</code>：是银行经营中常用到的一个术语，是影响银行经营业绩的一个重要变量；</p><p>银行经营过程中常用的<code>资金价格</code>分为三种：</p><ol><li>存款利率：是指客户在银行和其它金融机构所取得的利息与存款本金的比率；存款利率随着种类的不同而不同。存款周期越长，存款利率越高；反之存款周期越短，存款利率越低；</li><li>资金成本价格：是指银行经营中所有负债资金形成的资金的成本价，是涵盖存款、同业存款、准备金存款和现金在内的各种资金的平均价格；</li><li>贷款利率：货款利率是银行或其它金融机构发放贷款所取得的利息与贷款本金的比率。</li></ol><p>重要空白凭证：是指由商业银行或单位填写金额并经签章后即具有支取款项效力的空白凭证；（支票、本票、汇票、卡、存折、存单、证实书等）</p><p>商业银行经营<code>面临的主要风险</code>有：</p><table><thead><tr><th align="center">风险类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">信用风险</td><td align="center">又称为违约风险，是指借款人、证券发行人或交易对方因种种原因，不愿或无力履行合同条件而构成违约，致使银行、投资者或交易对方遭受损失的可能性</td></tr><tr><td align="center">市场风险</td><td align="center">指在证券市场中因股市价格、利率、汇率等的变动而导致价值未预料到的潜在损失的风险</td></tr><tr><td align="center">操作风险</td><td align="center">银行办理业务或内部管理出了差错，地震火灾等</td></tr><tr><td align="center">流动性风险</td><td align="center">指商业银行虽然有清偿能力，但无法及时获得充足资金或无法以合理成本及时获得充足资金以应对资产增长或支付到期债务的风险</td></tr></tbody></table><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><ol><li>贷款损失准备金包括：一般准备金、专项准备金、特种准备金；</li><li>银行业务：负债业务、资产业务、中间业务</li></ol><h2 id="第六章、银行的存款业务"><a href="#第六章、银行的存款业务" class="headerlink" title="第六章、银行的存款业务"></a>第六章、银行的存款业务</h2><p>存款的意义：存款是指银行吸收单位和居民个人存入的货币资金。存款业务是指银行以信用方式吸收社会闲置资金的筹资活动。<br>银行的存款产品通常分为：个人产品、公司产品和同业产品。<br>个人储蓄产品分为：活期存款、定期存款和人民币大额存单。<br>定期存款又分为：整存整取、零存整取、通知存款、存本取息、教育储蓄和定活两便</p><p>*活期存款的特点：</p><ol><li>每日计提利息（计提的分录，科目）</li><li>可设定结息周期</li><li>支持分段计息、单户结息和批量结息</li><li>满足活期账户/协定账户/透支账户</li><li>提供对账单</li><li>可支持存折/支票</li></ol><p>*定期存款的特点：</p><ol><li>每日计提利息</li><li>支取时一次性结息</li><li>可提前支取或到期支取</li><li>到期可本金转存或本息转存</li><li>到期支付活期存款利息</li><li>到期日为节假日的处理</li></ol><h3 id="1-活期储蓄存款"><a href="#1-活期储蓄存款" class="headerlink" title="1.活期储蓄存款"></a>1.活期储蓄存款</h3><p>概念：是存款时不限定存期，可随时存取的业务，起存金额为1元，外汇为20元等值人民币。<br>特点：方便将个人生活待用款和暂时不用款暂存；存取款灵活方便；还具有代收代付、代发工资等功能；个人活期存款按支取日利率计息。<br>计息规则：按支取日存款利率计息，算头不算尾</p><h3 id="2-整存整取"><a href="#2-整存整取" class="headerlink" title="2.整存整取"></a>2.整存整取</h3><p>概念：存款时约定存期并一次将现金整笔存入，到期后一次支取本息。<br>特点：利率高，但受时间限制，一旦提前支取，损失较大。适用于有预见性使用的或长期不使用的资金。<br>计息规则：按存款日存款利率计息，逾期时预期部分利率按活期；提前支取也是按活期。</p><h3 id="3-零存整取"><a href="#3-零存整取" class="headerlink" title="3.零存整取"></a>3.零存整取</h3><p>概念：存款人约定存期，以开户日为准，每月按约定的固定金额存入一次，到期一次性支取本金和利息。<br>特点：逐月存储，适合有固定收入的；中途漏存可次月补齐；连续漏存两次视为违约，违约后存入的部分，支取时按活期。<br>计息规则：按存款日存款利率计息，逾期时利率按活期；提前支取也是按活期。</p><h3 id="4-存本取息"><a href="#4-存本取息" class="headerlink" title="4.存本取息"></a>4.存本取息</h3><p>概念：约定存期和取息期，一次性存入本金，分次支取利息，到期后一次支取本金的定期储蓄存款业务。<br>特点：带来较高的利息收入；开户时可以选择约定转存；可以做质押贷款；可以办理提前支取。<br>计息规则：到期支取本金，分次支取利息；不可提前支取利息，遇取息日未取息，以后可以随时补取息；可以办理提前支取，全部提前支取时按活期，需要补已取利息</p><h3 id="5-教育储蓄"><a href="#5-教育储蓄" class="headerlink" title="5.教育储蓄"></a>5.教育储蓄</h3><p>概念：针对接受非义务教育而存入的储蓄资金实行的利率优惠、利息免税的一种零存整取定期储蓄存款业务。起存金额为50，每份本金不得超过2万；<br>特点：存期灵活、总额控制、利率优惠、利息免税、定向使用等特点。能积零成整，满足中低收入家庭每月固定小额存储，积蓄资金。<br>计息规则：提供学生证明的享受利息税优惠，只能提前支取全部并按活期。</p><h3 id="6-通知存款"><a href="#6-通知存款" class="headerlink" title="6.通知存款"></a>6.通知存款</h3><p>概念：存款时不约定存期，一次性存入本金，可以一次或多次支取，支取时需提前通知营业机构，约定支取存款日期和金额的业务。<br>特点：利率高于活期，灵活、支取方便，能获得较高收益，适用于大额、存取较频繁的存款。<br>计息规则：①实际存期不足通知期限，按活期；②未提前通知而支取的，支取部分按活期；③已办理通知手续而提前支取的，支取部分按活期；④支取金额不足或超过通知金额的，不足或超过部分按活期。</p><h3 id="7-定活两便"><a href="#7-定活两便" class="headerlink" title="7.定活两便"></a>7.定活两便</h3><p>概念：存款时不约定存期，一次性存入本金，可随时一次性支取本金和利息的业务。<br>特点：方便灵活，收益较高；手续简便，利率合理。存款期限不受限制，适合存款期限不确定的客户。<br>计息规则：存期不满三个月按活期；三到六个月按三个月整存整取利率的0.6；六个月到一年按六个月整存整取利率的0.6；一年以上的按一年整存整取利率的0.6。</p><h3 id="8-人民币大额存单"><a href="#8-人民币大额存单" class="headerlink" title="8.人民币大额存单"></a>8.人民币大额存单</h3><p>概念：面向个人和企业、机构客户发行的记账式大额存款电子化凭证，是具有标准化期限、最低投资金额要求、市场化定价的存款产品。按照人民银行相关规定，大额存单纳入存款保险范围。<br>特点：标准存款，本息安全；方便灵活，附加不同流动性支持；市场化定价，收益更高。</p><h3 id="9-对公存款账户"><a href="#9-对公存款账户" class="headerlink" title="9.对公存款账户"></a>9.对公存款账户</h3><p><strong>基本存款帐户</strong>：是单位的主办账户，单位的主要转账收付及工资、奖金和日常现金的支取，必须通过该账户办理。存款人只能在银行开立一个基本存款账户，其它银行结算账户的开立必须以基本存款账户的开立为前提。<br><strong>一般存款帐户</strong>：是存款人因借款或其它结算需要，在基本存款账户开户行以外的银行营业机构开立的银行结算账户；该账户可以办理现金缴存，但不得办理现金支取，一般存款账户没有数量限制。<br><strong>临时存款帐户</strong>：是存款人因临时需要并在规定期限内使用而开立的银行结算账户，临时存款账户需要确定有效期，可支取现金，有效期限不得超过2年。注册验资的临时存款账户在验资期间只收不付。<br><strong>专用存款帐户</strong>：是存款人按照法律、行政法规和规章，对其特定用途资金进行专项管理和使用而开立的银行结算账户。未经人民银行批准，不得在专用账户中支取现金。</p><h3 id="10-银行卡"><a href="#10-银行卡" class="headerlink" title="10.银行卡"></a>10.银行卡</h3><p>核心功能：设置帐户功能、存款功能、取款功能<br>基本功能：转账功能、贷款功能、常规消费功能<br>服务功能：手机银行等…</p><h3 id="11-银行账户的分类"><a href="#11-银行账户的分类" class="headerlink" title="11.银行账户的分类"></a>11.银行账户的分类</h3><table><thead><tr><th align="center">账户类型</th><th align="center">开户方式</th><th align="center">功能</th><th align="center">额度</th></tr></thead><tbody><tr><td align="center">I类</td><td align="center">传统柜面开户</br>经银行工作人员现场核验身份信息的自助机开户</td><td align="center">属全功能银行结算账户，安全等级最高、可存取现金、理财、转账、缴费、支付等。</td><td align="center">不限</td></tr><tr><td align="center">II类</td><td align="center">传统柜面开户</br>未经银行工作人员现场核验身份信息的自助机开户</br>电子渠道开户</td><td align="center">具备理财+支付功能；可以购买理财产品和消费支付，不得存取现金。</td><td align="center">单日最高1万，理财除外</td></tr><tr><td align="center">III类</td><td align="center">同II类</td><td align="center">限定金额的消费和缴费支付</td><td align="center">账户余额不得超过1000，超额原路返还同名I类账户</td></tr></tbody></table><h3 id="存款利息的计算"><a href="#存款利息的计算" class="headerlink" title="存款利息的计算"></a>存款利息的计算</h3><p>积数计息法：按实际天数每日累计账户余额，以累计积数乘以日利率计算利息</p><ul><li>利息 = 累计计息积数 * 年利率 / 360</li></ul><p>逐笔计息法：按预定的计息公式逐笔计算利息，分为对年、月、日：</p><ul><li>利息(到期取) = 本金 * 年(月)数 * 年(月)利率</li><li>利息(到期未取) = 本金 * 年(月)数 * 年(月)利率 + 本金 * 零头天数 * 日利率</li><li>利息 = 本金 * 实际天数 * 日利率</li></ul><p>利率换算规则：</p><ul><li>日利率 = 年利率 / 360</li><li>月利率 = 年利率 / 12</li><li>日利率 = 月利率 / 30</li></ul><p>利息计算规则：</p><ul><li>各种存款“算头不算尾”的办法计算计息天数。</li><li>计息起点以元为单位，元以下的角、分不计利息。</li><li>利息金额算至厘位，计至分位，分位以下四舍五入。</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ol><li>公司存款业务：协议存款、结构性存款</li><li>常用的账户状态：预开户、正常、冻结、长期不动户、久悬户、销户</li></ol><h2 id="第七章、银行支付结算与贷款"><a href="#第七章、银行支付结算与贷款" class="headerlink" title="第七章、银行支付结算与贷款"></a>第七章、银行支付结算与贷款</h2><h3 id="1-支付结算的支付工具"><a href="#1-支付结算的支付工具" class="headerlink" title="1.支付结算的支付工具"></a>1.支付结算的支付工具</h3><p>按形式划分：采用的结算形式不同，结算方式分为现金结算和非现金结算；现金结算是当事人直接用现金货币兑付的行为，非现金结算是当事人通过银行将款项从付款方划转到收款方的行为；<br>按工具划分：依据结算工具不同，分为票据结算和非票据结算；票据结算是以票据作为支付工具结算的行为（例如汇票、本票、支票），非票据结算是客户间以结算凭证为依据来结算的行为（例如银行卡、汇兑、托收承付、委托收款）</p><p>票据的功能：</p><ol><li>支付功能</li><li>汇兑功能：一国货币所具有的购买外国货币的能力。</li><li>信用功能：票据当事人可以凭借自己的信誉，将未来才能获得的金钱作为现在的金钱来使用。</li><li>结算功能：债务抵消功能。</li><li>融资功能：融通资金或调度资金，是通过票据的贴现、转贴现和再贴现实现的。</li><li>流通作用：票据的转让无需通知其债务人，只要票据要式具备就可交付或背书转让票据权利。</li></ol><p>种类：</p><ol><li>汇票：是出票人签发的，委托付款人在见票时或者在指定日期无条件支付确定的金额给收款人或者持票人的票据。<ol><li>按付款人不同：银行汇票、商业汇票</li><li>按有无附属单据：光票汇票、跟单汇票</li><li>按付款时间：即期汇票、远期汇票（远期汇票按承兑人分为：商业承兑、银行承兑汇票）</li><li>按流通地域：国内汇票、国际汇票</li><li>行为：出票 → 提示 → 承兑 → 收款 → 背书 → 贴现 → 拒付 → 追索 → 出票</li></ol></li><li>本票：是出票人签发的，承诺自己在见票时无条件支付确认的金额给收款人或者持票人的票据。<ol><li>按是否载明收款人姓名：记名本票、不记名本票</li><li>按有无到期时间：定期本票和即期本票</li><li>按支付方式：现金本票和转账本票</li><li>用途：远期付款、借贷凭证、筹集资金、提取款项</li></ol></li><li>支票：是出票人签发的，委托办理支票存款业务银行或其它金融机构在见票时无条件支付确定金额给收款人或者持票人的票据。<ol><li>特征：①是委付证券，但支票的付款人比较特殊，必须是有支付存款业务资格的银行或金融机构；②只有即期支票，支票无承兑制度</li><li>分为现金、转账和普通支票，普通支票可以支取现金和转账</li><li>特点：①使用方便，手续简便、灵活；②支票的提示付款期限自出票起10天；③支票可以背书转让，但用于支取现金的支票不可以</li></ol></li><li>银行卡：是指经批准由商业银行向社会发行的具有消费信用、转账结算、存取现金等全部或部分功能的信用支付工具。<ol><li>按额度：信用卡、借记卡</li><li>按载体：磁条卡、芯片卡</li><li>按发行主体：境内卡、境外卡</li><li>按对象：个人卡、单位卡</li><li>按币种：人民币卡、外币卡、多币种</li></ol></li><li>汇兑：是指汇款人委托银行将其款项支付给收款人的结算方式。汇兑便于汇款人向收款人主动付款。<ol><li>结算适用范围广，手续简便易行，灵活方便</li><li>分为电汇和信汇</li><li>特点：①没有金额起点的限制；②应用广泛，任何汇款人向异地主动付款的结算都可采取汇兑；③既可以单位间、个人间，也可以单位对异地个人；④手续简便易行</li></ol></li><li>托付承付：又称为异地托收承付，是根据购销合同由收款人发货后委托银行向异地付款人收取款项，由付款人向银行承认付款的结算方式。</li><li>委托收款：是收款人委托银行向付款人收取款项的结算方式。委托收款便于收款人主动收款，该结算方式适用范围十分广泛。无论是同城还是异地都可以使用。<ol><li>分为邮寄和电报划回</li><li>不受金额起点限制</li></ol></li></ol><h3 id="2-贷款业务"><a href="#2-贷款业务" class="headerlink" title="2.贷款业务"></a>2.贷款业务</h3><p>资产定义：是指商业银行通过对其资金加以运用，从而形成其各项资产业务。<br>资产内容：主要包括发放贷款、投资业务和其它资产业务。<br>资产分类：现金资产、长期投资、固定资产、无形资产以及其它资产。<br>贷款的意义：是银行以偿还和付息为条件，将资金提供给需求者的一种信用活动。贷款业务是银行的主要资产业务，也是银行会计核算的重要内容。</p><ul><li>按权责：自营贷款、委托贷款</li><li>按贷款期限：短期、中期、长期贷款</li><li>按贷款担保条件：信用、担保贷款、票据贴现</li><li>按贷款对象：工业、商业、农业、银团、外贸、小额抵押贷款</li><li>按资产质量：应计贷款和非应计贷款（比如30年的房贷，今年应还1万，还剩29万，则应计贷款是1万，属于应收）</li><li>按贷款风险：正常、关注、次级、可疑、损失五类，后三类合称不良贷款</li></ul><p>贷款常用名词：</p><ul><li>展期：因故不能到期归还贷款本金，而不得不延长贷款期限。（需要提前向银行申请，不是到期时）</li><li>利息：借款人依据借款合同支付给贷款人的资金成本。</li><li>罚息：因不能按时归还本金产生的利息。</li><li>复利：不能归还的利息而产生的利息。</li><li>利随本清：指借款人一次性的归还本金和利息。</li><li>抵押物：房产、汽车。</li><li>质押物：动产、定期存单。（手表、项链…）</li></ul><p>贷款流程：贷款申请 → 贷款评估 → 贷款调查 → 贷款审批 → 签订贷款合同 → 贷款发放 → 贷后检查 → 贷款归还</p><p>还款方式</p><ul><li>一次性还本付息：借款人到期时一次性换完</li><li>等额本息还款法：每次还款利息一致，每月还款一致（银行会建议这种，因为利息多）</li><li>等额本金还款法：每次还款本金一致，利息会越来越少，因为本金越来越少（钱多选这个）</li><li>分段等额本息还款：总共60万，前面还20，后面还60</li></ul><p>贷款利息计算方式：</p><ul><li>按季计息：每一季度末月20日结息，21日扣款入账</li><li>利随本清：归还贷款时一次性计息，贷款本金利息一次性扣款入账<br>  本金 * 天数 * 贷款日利率</li><li>贴现计息：发放时一次性计息扣款入账</li><li>罚息：罚息额 = 逾期额 * 天数 * 逾期日利率</li><li>复利：复息额 = 欠息 * 天数 * 贷款日利率</li></ul><p>贷款科目设置：</p><ul><li>“贷款”科目：资产类科目</li><li>“应收利息”科目：资产类科目</li><li>“贷款损失准备”科目：资产类科目</li><li>“利息收入”科目：损益类科目，实收负债</li></ul><p>贷款核算：</p><ol><li>发放（贷款转存，开立一般存款账户）<br> 借：贷款→资产性质的增加<br> 贷：现金→资产性质的减少</li><li>计息<br> 借：应收利息→资产性质的增加<br> 贷：利息收入→负债性质的增加</li><li>归还<br> 借：现金→资产性质的增加<br> 贷：贷款→资产性质的减少<br> 贷：应收利息→资产性质的减少</li><li>逾期<br> 借：贷款-信用逾期贷款→资产性质的增加<br> 贷：贷款-信用贷款→资产性质的减少</li></ol><h2 id="第八章、银行的会计核算"><a href="#第八章、银行的会计核算" class="headerlink" title="第八章、银行的会计核算"></a>第八章、银行的会计核算</h2><h3 id="1-银行的记账"><a href="#1-银行的记账" class="headerlink" title="1.银行的记账"></a>1.银行的记账</h3><p>银行的记账采用复式记账法，记账规则：</p><ol><li>以“借”、“贷”为记账符号；</li><li>凡资产增加、负债减少、利益减少、损失增加记为借；</li><li>凡资产减少、负债增加、利益增加、损失减少记为贷；</li><li>有借必有贷，借贷必相等；</li><li>记账方向：借在左，贷在右；</li><li>各科目借、贷发生额和余额，其合计各自相平衡。</li></ol><p>银行的财务种类分为对内账务和对外账务：</p><ul><li>对内账务：是银行根据自身业务就经营管理需要而设置的账务，例如：现金、固定资产、暂收款项、暂付款项等账务；</li><li>对外账务：是银行根据账务管理规定，为存款人或贷款人以及往来银行设立的独立账户，一般分为存款类、贷款类、往来类等账户。</li></ul><p>银行的财务组织：</p><ul><li>明细核算：<ul><li>分户账：是各科目的明细记录，必须按户立账，连续记载；</li><li>登记簿：金额户 数登记簿、开销户登记簿、挂失登记薄、现金登记簿、重要空白凭证登记簿、有价单证登记簿、托收登记簿、代保管有价值品登记簿。</li></ul></li><li>综合核算：<ul><li>科目日结单：是监督明细账务发生额，扯平当天账务的重要工具；</li><li>总账</li><li>日记表</li></ul></li></ul><h3 id="2-银行的损益"><a href="#2-银行的损益" class="headerlink" title="2.银行的损益"></a>2.银行的损益</h3><p>概念：是指一定经营时期内，以各项收入抵补各项支出之后的最终结果，如果收入大于支出是利润，小于是亏损。<br>银行的收入：</p><ol><li>营业收入：利息、金融企业往来、手续费、汇兑、其它营业收入</li><li>营业外收入：财产盘盈、固定资产清理、罚没、罚款收入</li><li>外汇经营收入</li><li>投资收入</li></ol><p>银行的支出：</p><ol><li>营业支出</li><li>营业外支出</li><li>外汇经营支出</li><li>税金支出</li></ol><h3 id="3-银行的利润"><a href="#3-银行的利润" class="headerlink" title="3.银行的利润"></a>3.银行的利润</h3><p>银行利润的概念：是银行在一定时期内全部经营活动的最终结果。<br>银行利润的核算：每一个会计年度终了，银行都要结转利润，将损益类账户余额全部结转到“本年利润”科目账务中，即将收益类账户余额结转到“本年利润”科目的贷方，而成本类账务余额结转到“本年利润”的借方，“本年利润”科目如为贷方余额，则为本期利润总额，为借方余额则为本期亏损总额。</p><h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><h3 id="项目实施方法论"><a href="#项目实施方法论" class="headerlink" title="项目实施方法论"></a>项目实施方法论</h3><p>什么是项目？<br>为了一个明确的目标，在特定的时间、预算、资源限定内，完成一系列独特的、复杂的并相互关联的活动。公司开发一个新产品、学校的毕业设计答辩、组织一次同学聚会。</p><p>什么是项目实施？<br>就是项目计划的执行和项目过程的控制。</p><p>什么是方法论？<br>就是人们用什么样的方式、方法来观察事务和处理问题。主要解决“怎么办”问题。</p><p>什么是项目实施方法论？<br>通俗的说，就是告诉大家如何开展项目实施工作的理论。再具体点，就是让大家从全局的角度认识项目实施。</p><p>学习项目实施方法论的好处？<br>①告别初进项目的迷茫：新员工刚到项目组，往往不知道该做什么，非常被动，如果学习了项目实施方法论，就知道项目需要做什么，从而更好的理解自己的工作职责，能够主动的接受并完成工作；<br>②表现的像职业老手：通过学习项目实施方法论，了解了在项目什么阶段该做什么事，使用合适的方法和技巧去完成任务，获得自我提升；</p><h3 id="项目实施管理"><a href="#项目实施管理" class="headerlink" title="项目实施管理"></a>项目实施管理</h3><p>项目进度计划是指在确保项目工期和主要里程碑时间的前提下，对项目实施过程合理安排，以达到合理利用资源、降低费用支出的目的。</p><p>项目组织架构：是指所有工作都围绕项目进行、通过项目创造价值并达成自身战略目标的组织架构</p><p>版本管理：是确保软件工作产品在其生命周期中的一致性，确保发布版本的规范度和准确性。使用版本管理仅可以对文件、目录、链接进行版本控制。同时还支持并行开发。</p><p>变更管理：为确保项目范围的完整性，需要有效地管理基线变更，并跟踪变更的实现。变更管理包括：需求变更、技术设计变更…</p><p>质量管理：活动包括严格的交付物评审、严格的测试策略以及质量保证（QA）活动。</p><h3 id="项目流程"><a href="#项目流程" class="headerlink" title="项目流程"></a>项目流程</h3><p>项目流程：项目启动 → 需求分析 → 系统设计 → 开发和单元测试 → 集成测试 → 系统测试 → 用户验收测试 → 上线<br>项目启动是指成功启动一个项目的过程，具体指开始计划针对项目的目标和最终结果的各种管理行为，包含编制和确认项目工作说明书、制订项目实施计划、召开项目启动会三步。<br>需求分析是指需求分析人员经过讨论和分析，准确理解项目的业务功能和性能等具体要求，并形成需求文档的过程，包含搭建部署系统操作环境和需求规格说明书编制。<br>系统设计是指在编写系统客户化的数据库设计、概要设计和详细设计，系统设计的相关产物需要通过甲乙双方组织的技术评审。<br>开发和单元测试是项目投入资源最多，开发工作量最大的阶段，产生项目交付的实质内容，包含代码开发、代码走查和单元测试。<br>集成测试是系统测试之前由项目组自行进行的内部测试，以确保交付给系统测试环节的软件版本的功能满足预期的质量要求，包含集成测试准备、集成测试执行和集成测试总结。<br>测试案例要有小标题，测什么的，第二是测试的目标，第三是测试步骤，第四是预测结果，第五是实际步骤，第六是实际结果，第七是是否测试通过。<br>上线及保障包括切换步骤与任务单下发、规章制度下发、生产环境准备等，按计划完成生产数据迁移及新系统投产上线。</p><h3 id="信息安全"><a href="#信息安全" class="headerlink" title="信息安全"></a>信息安全</h3><p>什么是信息安全？<br>信息本身的机密性、完整性和可用性的保持，即防止未经授权使用信息、防止对信息的非法修改和破坏、确保及时可靠地使用信息。</p><p>信息安全管理体系方针：<br>预防为主，控制信息安全风险；<br>强化监督，遵守有关规章制度；<br>以人为本，提高全员安全意识；<br>科学管理，实现效能持续改进。</p><h2 id="神州信息企业服务总线-SmartESB"><a href="#神州信息企业服务总线-SmartESB" class="headerlink" title="神州信息企业服务总线-SmartESB"></a>神州信息企业服务总线-SmartESB</h2><p>石锦鹏——技术总监<br>在ESB这块打败IBM、Oracle，涵盖银行、房地产、保险、能源、制造业等，市场占有率90%</p><p>微服务架构：其实和SOA架构类似，微服务是在SOA上做的升华，微服务架构强调的一个重点是“业务需要彻底的组件化和服务化”，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用，这些小应用之间通过服务完成交互和集成。</p><p>SOA：面向服务的架构，是一种设计方法，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在于操作系统进程中，各个服务之间通过网络调用。<br>ESB：企业服务总线，就像是一根管道，用来连接各个服务节点。为了集成不同系统，不同协议(协议+报文：<code>Tcp+txt</code>、<code>HTTP+json</code>、<code>MQ+xml</code>、<code>WS+soap</code>、<code>JMS+json</code>)的服务，ESB做了消息的转化解释和路由工作让不同的服务互联互通。<br>协议+报文<br>消息队列：IBM的MQ、Oracle的JMS、神码MOM</p><p>传统架构的<code>点对点</code>虽然快，但存在以下问题：</p><ul><li>交易路径复杂、业务和技术相混杂；</li><li>性能瓶颈、扩展能力差；</li><li>开发无需、没有标准、技术管理越来越困难；</li><li>拼拼凑凑，没有规划，线路复杂、维护成本激增，易出故障难以修复；</li><li>稳定性差，无法应对互联网大交易量冲击；</li><li>没有全局监控、管控与业务治理；</li></ul><p>Sm@rtESB的特点：</p><ul><li><strong>作用</strong>：协议适配、报文适配、智能路由、流量控制、监控告警、服务组合、冲正补偿、治理管控…</li><li>解耦：高内聚、低耦合、维护、扩展、替换、升级方便；</li><li>复用：灵活、快捷、高效的组装；</li><li>稳定：流量控制、故障隔离、异常处理等机制保障稳定性，能够应对互联网冲击；</li><li>标准：统一治理，服务标准化；</li><li>管控：统一管理，全局监控，维护方便成本低；</li></ul><p>ESB就像习大大的一带一路、翻译官、像一条高速公路连接各个村<br>in router out</p><h3 id="名称概念"><a href="#名称概念" class="headerlink" title="名称概念"></a>名称概念</h3><p>服务消费者：交易的发起方，也叫请求方，前端请求方系统；<br>服务提供方：交易所要调用的目标系统，也叫后端提供方系统；</p><p>业务服务：服务提供方系统发布到ESB上原子服务叫做业务服务；<br>服务系统：ESB上指服务提供方系统；<br>渠道：ESB上指服务消费方。</p><p>接入协议：ESB分配给消费方的访问地址，即消费方请求ESB的通讯地址；<br>接出协议：ESB访问提供方系统的访问地址，即提供方系统的实际地址；</p><p>适配流程：适配流程也叫数据适配，在ESB上是指对交易报文数据进行处理的流程；<br>渠道适配流程：ESB上在渠道上配置的适配流程叫做“渠道适配流程”；<br>服务适配流程：ESB上在服务上配置的适配流程叫做“服务适配流程”；<br>服务识别规则、系统识别规则，动态、静态识别。</p><p>五个服务：服务识别、系统识别、拆包、组包、服务路由；</p><p>穿透：ESB收到消费方请求报文后不做任何处理，直接路由给服务提供方的交易模式；<br>报文拆组包：消费方发送的报文和提供方能处理的报文类型不一致，需要由ESB完成报文转换的交易模式；<br>SDO：ESB内部标准数据格式；<br>报文拆包：ESB将收到的前端请求报文或后端响应报文拆成ESB内部标准数据格式SDO的过程；<br>报文组包：ESB将SDO组合成后端能够处理的请求报文或将SDO组合成前端能够处理的响应报文；</p><p>ESB流程：</p><ol><li>消费者调用ESB；</li><li>ESB的接入容器IN进行服务识别；</li><li>拆包；</li><li>服务路由ConsumerClientServer；</li><li>ESB的接出容器OUT进行系统识别；</li><li>组包；</li><li>业务服务；</li><li>服务提供者响应数据；</li><li>拆包；</li><li>进入router；</li><li>进入服务路由；</li><li>组包；</li><li>返回前端消费者；</li></ol><p>atm(渠道) → Pay(服务) → core(系统)：<br>metadata.xml<br>service_Pay.xml<br>chanel_atm_service_Pay.xml（请求拆包）<br>service_Pay_system_core.xml（响应组包）<br>chanel_core_service_Pay.xml（响应拆包）<br>service_Pay_system_atm.xml（请求组包）</p><h3 id="产品安装"><a href="#产品安装" class="headerlink" title="产品安装"></a>产品安装</h3><p>先启动MOM队列，因为需要完成console和ESB之间的通信，上面有两个队列分别监听console和ESB；在启动console之前需要先安装数据库，而console需要与数据库交互；最后启动ESB</p><h4 id="Linux下启动"><a href="#Linux下启动" class="headerlink" title="Linux下启动"></a>Linux下启动</h4><ol><li>查看文件信息<pre><code class="hljs shell">ls -lrt</code></pre></li><li>赋予执行权限<pre><code class="hljs shell">chmod 775 *bin</code></pre></li><li>查看剩余空间<pre><code class="hljs shell">free -g</code></pre></li></ol><h5 id="安装消息中间件MOM"><a href="#安装消息中间件MOM" class="headerlink" title="安装消息中间件MOM"></a>安装消息中间件MOM</h5><ol><li>安装消息中间件<pre><code class="hljs shell">./ SmartMOM.bin -i console</code></pre></li><li>启动消息中间件<pre><code class="hljs shell">./StartMessageServer.sh</code></pre></li><li>后台启动消息中间件<pre><code class="hljs shell">nohup ./StartMessageServer.sh &amp; tail -f nohup.outnohup ./StartMessageServer.sh &gt; mom.log &amp; tail -f mom.out</code></pre></li><li>关闭消息中间件，需要携带端口和ip<pre><code class="hljs shell">./StopMessageServer.sh 127.0.0.1 7799</code></pre></li><li>查看java进程<pre><code class="hljs shell">ps -ef|grep javaps -ef|grep Main</code></pre></li><li>配置日志级别<pre><code class="hljs text">1. 第一行等号后面第一个值是服务的日志级别error2. 第二个值是console的话，会在控制台输出日志</code></pre></li></ol><h5 id="安装企业服务总线ESB"><a href="#安装企业服务总线ESB" class="headerlink" title="安装企业服务总线ESB"></a>安装企业服务总线ESB</h5><ol><li><p>安装ESB</p><pre><code class="hljs shell">./ SmartESB.bin -i console安装过程需要确认jdk、安装路径、jdbcURL</code></pre></li><li><p>创建数据库用户</p></li><li><p>在安装目录下找到数据库文件并执行</p></li><li><p>启动服务</p><pre><code class="hljs text">1. 启动console：./startConsole.sh    报错，需要上传一个license文件到bin目录下，然后后台启动nohup ./startConsole.sh &gt; console.out &amp; tail -f console.out2. 启动esb(包括in、router、out)nohup ./startSmart.sh &gt; all.log &amp; tail -f all.log</code></pre></li><li><p>后台启动消息中间件</p><pre><code class="hljs shell">nohup ./StartMessageServer.sh &amp; tail -f nohup.outnohup ./StartMessageServer.sh &gt; mom.log &amp; tail -f mom.out</code></pre></li><li><p>关闭消息中间件，需要携带端口和ip</p><pre><code class="hljs shell">./StopMessageServer.sh 127.0.0.1 7799</code></pre></li></ol><h4 id="Windows下启动"><a href="#Windows下启动" class="headerlink" title="Windows下启动"></a>Windows下启动</h4><ol><li>修改MOM安装目录下启动、关闭bat文件的jdk路径；</li><li>修改SEB安装目录下：<br> 2.1 bin/setESBEnv.cmd的jdk路径；<br> 2.2 configs/console_conf/conf/dbconfig.xml和proxool.xml的数据库用户名<br> 2.3 middleware/tomcat/webapps/esbconsole/WEB-INF/classes/config-oracle.properties的数据库用户名<br> 2.4 DB_scripts/esbconsole.bat的数据库用户名</li><li>运行Oracle安装目录下的BIN/sqlplus.exe 不要关闭，打开就可以了</li><li>启动StartMessageServer.bat、DB_scripts/esbconsole.bat、console、smart</li></ol><p>natstat -an | findstr 4545</p><h3 id="1-课堂作业"><a href="#1-课堂作业" class="headerlink" title="1.课堂作业"></a>1.课堂作业</h3><ol><li><p>配置接入协议</p><pre><code class="hljs text">httpPosIn6001http://127.0.0.1:6001/esb/pos</code></pre><p><img src="/resource/img/workplace/DCITS/esb/1.png"><br>下方接入协议<br><img src="/resource/img/workplace/DCITS/esb/2.png"></p></li><li><p>配置接出协议</p><ol><li>先设置http服务提供方响应报文，然后复制自动出现的地址<pre><code class="hljs text">http://127.0.0.1:80081/rsbconsole/httpServer</code></pre><img src="/resource/img/workplace/DCITS/esb/3.png"></li><li>然后设置接出协议<br><img src="/resource/img/workplace/DCITS/esb/4.png"></li><li>下发接出协议<br><img src="/resource/img/workplace/DCITS/esb/5.png"></li></ol></li><li><p>配置渠道：pos<br><img src="/resource/img/workplace/DCITS/esb/6.png"></p></li><li><p>配置服务：posSvc<br><img src="/resource/img/workplace/DCITS/esb/7.png"></p></li><li><p>配置识别规则<br><img src="/resource/img/workplace/DCITS/esb/8.png"></p></li><li><p>测试<br><img src="/resource/img/workplace/DCITS/esb/9.png"></p></li></ol><h3 id="2-配置动态识别规则"><a href="#2-配置动态识别规则" class="headerlink" title="2.配置动态识别规则"></a>2.配置动态识别规则</h3><p><code>渠道绑定服务</code></p><ol><li>适配管理→识别规则管理<br><img src="/resource/img/workplace/DCITS/esb/10.png"></li><li>测试<br><img src="/resource/img/workplace/DCITS/esb/11.png"></li></ol><h3 id="3-新增系统识别"><a href="#3-新增系统识别" class="headerlink" title="3.新增系统识别"></a>3.新增系统识别</h3><p><code>服务绑定系统</code></p><ol><li>新增out识别规则<br><img src="/resource/img/workplace/DCITS/esb/12.png"></li><li>修改系统识别<br><img src="/resource/img/workplace/DCITS/esb/13.png"></li><li>测试<ol><li>测试001<br><img src="/resource/img/workplace/DCITS/esb/14.png"></li><li>测试002<br><img src="/resource/img/workplace/DCITS/esb/15.png"></li></ol></li></ol><h3 id="4-新增系统"><a href="#4-新增系统" class="headerlink" title="4.新增系统"></a>4.新增系统</h3><ol><li>添加core银行管理系统<br><img src="/resource/img/workplace/DCITS/esb/16.png"></li><li>系统名<br><img src="/resource/img/workplace/DCITS/esb/17.png"></li><li>绑定接出协议<br>一个系统只能绑定一个接出协议<br><img src="/resource/img/workplace/DCITS/esb/18.png"></li><li>绑定服务<br>一个系统可以绑定多个服务，中间通过一条接出协议绑定<br><img src="/resource/img/workplace/DCITS/esb/19.png"></li></ol><h3 id="5-从头开始"><a href="#5-从头开始" class="headerlink" title="5.从头开始"></a>5.从头开始</h3><pre><code class="hljs text">假定有一个渠道c1，接入协议为httpC1In6001，地址为http://127.0.0.1:6001/esb/c1有两个服务s1和s2，s1指向在http8081的sys1，s2指向在tcp10013的sys2</code></pre><ol><li>协议管理<ol><li>新增接入协议<br><img src="/resource/img/workplace/DCITS/esb/20.png"></li><li>设置响应报文，从中获取接出协议地址</li><li>新增http接出协议<br><img src="/resource/img/workplace/DCITS/esb/21.png"></li><li>新增tcp接出协议，与http类似</li></ol></li><li>渠道管理<br><img src="/resource/img/workplace/DCITS/esb/22.png"></li><li>服务管理<ol><li>新增服务s1<br><img src="/resource/img/workplace/DCITS/esb/23.png"></li><li>新增服务s2：与s1类似，只是协议适配为tcp的out</li></ol></li><li>系统<ol><li>新增系统sys1<br><img src="/resource/img/workplace/DCITS/esb/24.png"></li><li>新增系统sys2：与sys2类似，只是配置为s2的out</li></ol></li><li>识别规则<ol><li>新增in<br><img src="/resource/img/workplace/DCITS/esb/25.png"></li><li>新增out<br><img src="/resource/img/workplace/DCITS/esb/26.png"></li></ol></li><li>适配流程<ol><li>配置渠道的<br><img src="/resource/img/workplace/DCITS/esb/27.png"></li><li>配置服务的：与配置渠道的类似</li></ol></li><li>测试</li></ol><h3 id="6-配置拆组包工程"><a href="#6-配置拆组包工程" class="headerlink" title="6.配置拆组包工程"></a>6.配置拆组包工程</h3><ol><li>在PC端修改渠道的适配流程<ol><li>修改IN的适配流程<br><img src="/resource/img/workplace/DCITS/esb/28.png"></li><li>修改OUT的适配流程<br><img src="/resource/img/workplace/DCITS/esb/29.png"></li></ol></li><li>在ESB运行目录下添加拆组包文件<pre><code class="hljs text">IN：/SmartESB/configs/in_conf/metadataOUT：/SmartESB/configs/out_conf/metadata</code></pre>公共的：<ul><li>metadata.xml元数据文件<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">?</span> <span class="hljs-attr">xml</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span> <span class="hljs-attr">encoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">metadata</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">soldier</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span> <span class="hljs-attr">length</span>=<span class="hljs-string">&quot;3&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cardno</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span> <span class="hljs-attr">length</span>=<span class="hljs-string">&quot;5&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">recode</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span> <span class="hljs-attr">length</span>=<span class="hljs-string">&quot;6&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">metadata</span>&gt;</span></code></pre></li><li>service_s1.xml服务s1配置文件<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">?</span> <span class="hljs-attr">xml</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span> <span class="hljs-attr">encoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">s1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">request</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">sdoroot</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">soldier</span> <span class="hljs-attr">metadataid</span>=<span class="hljs-string">&quot;soldier&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">cardno</span> <span class="hljs-attr">metadataid</span>=<span class="hljs-string">&quot;cardno&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">sdoroot</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">request</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">response</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">sdoroot</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">recode</span> <span class="hljs-attr">metadataid</span>=<span class="hljs-string">&quot;recode&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">sdoroot</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">response</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">s1</span>&gt;</span></code></pre>为IN容器添加:</li></ul><ol><li>channel_c1_service_s1.xml 将前端的请求报文拆包成SDO<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">?</span> <span class="hljs-attr">xml</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span> <span class="hljs-attr">encoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">res</span> <span class="hljs-attr">package_type</span>=<span class="hljs-string">&quot;xml&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">soldier</span> <span class="hljs-attr">metadataid</span>=<span class="hljs-string">&quot;soldier&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cardno</span> <span class="hljs-attr">metadataid</span>=<span class="hljs-string">&quot;cardno&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span></code></pre></li><li>service_s1_system_c1.xml 将SDO组包成前端可识别的响应报文<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">?</span> <span class="hljs-attr">xml</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span> <span class="hljs-attr">encoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">res</span> <span class="hljs-attr">package_type</span>=<span class="hljs-string">&quot;xml&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">recode</span> <span class="hljs-attr">metadataid</span>=<span class="hljs-string">&quot;recode&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">res</span>&gt;</span></code></pre>为OUT容器添加：</li><li>service_s1_system_sys1.xml 将SDO组包成后端可识别的请求报文<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">?</span> <span class="hljs-attr">xml</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span> <span class="hljs-attr">encoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">res</span> <span class="hljs-attr">package_type</span>=<span class="hljs-string">&quot;fix&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">soldier</span> <span class="hljs-attr">metadataid</span>=<span class="hljs-string">&quot;soldier&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cardno</span> <span class="hljs-attr">metadataid</span>=<span class="hljs-string">&quot;cardno&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">res</span>&gt;</span></code></pre></li><li>channel_sys1_service_s1 将后端的响应报文拆包成SDO<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">?</span> <span class="hljs-attr">xml</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span> <span class="hljs-attr">encoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">res</span> <span class="hljs-attr">package_type</span>=<span class="hljs-string">&quot;fix&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">recode</span> <span class="hljs-attr">metadataid</span>=<span class="hljs-string">&quot;recode&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span></code></pre></li></ol></li><li>测试<br><img src="/resource/img/workplace/DCITS/esb/30.png"></li></ol><h3 id="7-配置流水日志"><a href="#7-配置流水日志" class="headerlink" title="7.配置流水日志"></a>7.配置流水日志</h3><ol><li>为esb的journal配置数据库并启动<br><img src="/resource/img/workplace/DCITS/esb/31.png"><br>在esb安装目录的bin目录下面找到<code>startJournal</code>启动</li><li>适配流程管理<br><img src="/resource/img/workplace/DCITS/esb/32.png"></li><li>测试<br><img src="/resource/img/workplace/DCITS/esb/33.png"></li><li>还可以通过参数配置IN/OUT记录流水<br>这里配置了记录IN的第一个流水<br><img src="/resource/img/workplace/DCITS/esb/34.png"></li></ol><h3 id="8-配置全报文流水日志"><a href="#8-配置全报文流水日志" class="headerlink" title="8.配置全报文流水日志"></a>8.配置全报文流水日志</h3><p>作用：</p><ol><li>为监控提供统计交易量；</li><li>为冲正交易提供原流水信息、报文信息。</li></ol><p><code>冲正</code>：一般在银行里，ESB自动冲正，将错账冲销，主要用于保证事务的一致性。</p><ol><li>流水策略配置<br><img src="/resource/img/workplace/DCITS/esb/35.png"></li><li>流水信息查询<br><img src="/resource/img/workplace/DCITS/esb/36.png"></li></ol><h3 id="9-流量控制"><a href="#9-流量控制" class="headerlink" title="9.流量控制"></a>9.流量控制</h3><p>业务监控、服务器监控</p><ol><li>启动主备流量控制<br><img src="/resource/img/workplace/DCITS/esb/37.png"><br><code>两个同时启动</code></li><li>PC端节点管理<br><img src="/resource/img/workplace/DCITS/esb/38.png"></li><li>流程令牌管理<br><img src="/resource/img/workplace/DCITS/esb/39.png"></li><li>流程维度管理<br><img src="/resource/img/workplace/DCITS/esb/40.png"></li><li>适配流程管理<br><img src="/resource/img/workplace/DCITS/esb/41.png"></li><li>测试<br><img src="/resource/img/workplace/DCITS/esb/42.png"></li></ol><h2 id="神州信息SOA3-0企业级微服务平台"><a href="#神州信息SOA3-0企业级微服务平台" class="headerlink" title="神州信息SOA3.0企业级微服务平台"></a>神州信息SOA3.0企业级微服务平台</h2><p>刘天<br>SOA3.0架构<br>单主机系统（处理能力有限） → 网状系统（易集成难扩展，点对点） → SOA架构服务化（可管理可治理） → 微服务1.0（分布式去中心、服务化模块化） → 微服务2.0（开放化、自动化云化支持）</p><p>微服务概念：是一个软件架构形式。在这个架构中，复杂的应用程序是由多个小而独立的进程组成，每一个进程通过独立于语言的接口进行相互交流。这些服务较小、高度解耦且专注于完成一个小任务，使得用模块化方法建设系统更加容易。</p><p>特点：</p><ul><li>每个服务都很简单，只关注于一个业务功能；</li><li>每个微服务可以由不同的团队独立开发；</li><li>微服务是松散耦合的；</li><li>微服务可以通过不同的编程语言与工具进行开发。</li></ul><p>为什么使用微服务？</p><ol><li>单体应用模块间代码互相影响，简单的代码修改需要整体打包，整体测试，效率低下；</li><li>无法做到单一模块的扩展，每次扩展都需要整体应用扩展，造成资源浪费；</li><li>单体应用决定了应用内部必须采用同样的技术栈进行开发，内部应用</li></ol><p>挑战：</p><ul><li>运行管理难度大：服务治理、服务拆分、自动化运维、分布式管理；</li><li>异构系统复杂：存量系统微服务化难度大、开发框架难以统一、第三方产品新技术更新快；</li><li>多云多中心环境复杂：两地三中心、分布式并行架构、混合云架构PAAS、CAAS；</li><li>开源框架复杂多变：Dubbo、SpringCloud框架缺陷修复困难，需求复杂维护成本高；</li><li>分布式事务：CAP定律问题（C：一致性、A：可用性、P：分区容错性）；</li></ul><p>目的：</p><ul><li>技术能力统一；</li><li>技术方案统一；</li><li>治理组件统一；</li><li>治理标准统一；</li></ul><p><code>支持报文类型</code>：XML、JSON、ISO8583、Fix、SWIFI、SOP、定长、分割符、各种自定义报文；<br><code>支持通讯协议</code>：TCP、HTTP/HTTPS、Socket、JMS、MQ、EJB、WebService、RMI、Tuxedo、Tong-Link、CICS、自定义通讯协议；</p><h3 id="注册中心优势"><a href="#注册中心优势" class="headerlink" title="注册中心优势"></a>注册中心优势</h3><table><thead><tr><th align="center">功能</th><th align="center">Consul</th><th align="center">zookeeper</th><th align="center">Eureka</th><th align="center">SmartEureka</th></tr></thead><tbody><tr><td align="center">服务注册/服务发现客户端</td><td align="center">提供客户端（应用外注册）</td><td align="center">-</td><td align="center">提供客户端（应用外注册）</td><td align="center">提供客户端（应用外注册）</td></tr><tr><td align="center">服务发现权限</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">提供服务发现权限管理，认证服务发现客户端，仅返回具备服务调用权限的服务列表</td></tr><tr><td align="center">服务健康检查</td><td align="center">服务状态、内存、硬盘等</td><td align="center">弱连接</td><td align="center">可配支持</td><td align="center">可配支持，可以根据结合SpringBoot的健康状态支配根据应用整体健康状况，决定服务健康与否</td></tr><tr><td align="center">多数据中心</td><td align="center">支持</td><td align="center">-</td><td align="center">-</td><td align="center">支持</td></tr><tr><td align="center">一致性</td><td align="center">raft</td><td align="center">paxos</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">CAP</td><td align="center">CP</td><td align="center">CP</td><td align="center">AP</td><td align="center">基于Eureka的AP基础强化C</td></tr><tr><td align="center">使用接口（多语言能力）</td><td align="center">rest api</td><td align="center">客户端</td><td align="center">rest api</td><td align="center">rest api</td></tr><tr><td align="center">watch支持</td><td align="center">全量/支持long poling</td><td align="center">支持</td><td align="center">支持long poling/大部分增量</td><td align="center">支持通知更新机制/支持long poling/支持增量更新</td></tr><tr><td align="center">自身监控</td><td align="center">metrics</td><td align="center">-</td><td align="center">metrics</td><td align="center">metrics</td></tr><tr><td align="center">安全认证</td><td align="center">-</td><td align="center">-</td><td align="center">集成Spring Security</td><td align="center">集成Spring Security</td></tr><tr><td align="center">spring cloud集成</td><td align="center">已支持</td><td align="center">需开发</td><td align="center">已支持</td><td align="center">已支持</td></tr><tr><td align="center">易用性/可扩展性</td><td align="center">GO语言开发，更贴近SideCar模式</td><td align="center">不易用，作为注册中心功能不完善，大量功能需要定制化开发，容易踩坑</td><td align="center">java开发，提供易用的客户端/API</td><td align="center">java开发，提供易用的客户端/API</td></tr></tbody></table><p>微服务平台：</p><ul><li>管理平台；</li><li>注册中心：服务注册，分区选择，容灾多活，心跳探测，权限发现，数据同步；</li><li>配置中心：应用管理，环境管理，集群管理，配置发布，配置权限，操作审计；</li><li>日志中心：日志聚合、日志分析、日志查询；</li><li>认证中心：密码认证，JWT支持，证书管理，OAuth认证，签名认证，服务权限；</li><li>监控中心：监控指标、链路指标、监控告警、监控报表；</li><li>服务网关；</li><li>运行容器；</li><li>服务边车：服务发现、服务注册、服务路由、负载均衡、熔断降级、服务限流、安全认证、就绪检查、检查端点、配置端点、优雅停机、日志分离、模块化管理、幂等控制；</li><li>持续集成：流水线、自动构建、自动测试；</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>统一管理平台主要功能：持续部署、网管管理、服务管理、配置管理；</li><li>注册中心主要功能：支付微服务的自动注册，以及微服务和网关对服务自动发现，支持服务列表权限过滤；</li><li>微服务网关主要功能：微服务网关试微服务架构体系中的重要组成单元；</li><li>微服务运行容器主要功能：微服务运行容器提供微服务调用过程中的路由及负载均衡、服务的认证、微服务的熔断降低限流、服务的隔离等功能。同时支持微服务运行过程中监控数据采集；</li><li>服务边车主要功能：边车容器提供服务发现、服务注册、服务路由、负载均衡、熔断降级、服务限流、安全认证、就绪检查、优雅停机、日志分离、幂等控制等功能。同时支持微服务运行过程中监控数据采集；</li><li>授权认证中心主要功能：保证用户或平台资源、合理的对外开放；</li><li>日志中心主要功能：采用ELK Stack技术，提供实时的分布式搜索和分析引擎，它可以使用全文搜索，结构化搜索及分析，处理问题排查；</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>监控平台：资源监控、应用监控、调用链监控、监控报表、多中心监控、监控告警、监控面板、监控采集；</li><li>微服务统一管理平台：用户管理、注册中心、微服务管理，网关管理，告警管理；</li><li>微服务管理详细功能如下：接口管理、证书信息、负载信息、版本管理、实例信息、熔断信息、授权信息、流量控制；</li><li>网关管理详细功能如下：协议管理、服务路由、元数据管理、拆组包配置管理、服务识别配置、故障隔离管理、报文解析器管理、基础服务管理、流程适配管理；</li><li>微服务网关：服务授权、服务注册和发现、服务熔断/降级、协议适配、报文适配、报文穿透、服务路由、服务限流、故障隔离、超时控制、负载均衡(一般使用轮询)、网管版本发布、网管重启；</li><li>微服务运行容器：路由及负载、服务认证、服务限流、服务熔断降级；</li><li>服务边车：服务发现与路由、负载均衡、服务熔断、服务舱壁；</li><li>认证中心：认证中心支持服务认证；</li><li>注册中心：服务注册和发现、服务关系管理；</li><li>配置中心：配置实时同步、注解获取、占位符获取、XML获取、程序编码获取、客户端主动获取、服务端主动推送、版本管理、自定义发布、灰度发布、蓝绿部署、A/B测试、授权与审核、客户端支持、日志中心、高可用易扩展架构；</li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ol><li>Eureka：服务的注册和发现，将自己定义的API接口注册到Spring Cloud Eureka上，由服务注册中心、服务提供者和消费者构成；</li><li>Ribbon：客户端负载均衡器，Eureka只维护了服务生产者、注册中心和消费者间的关系，而这真正的服务消费者调用服务生产者提供的数据是通过Spring Cloud Ribbon来实现的，</li><li>Feign：可以简化我们的编码，是一个声明web服务客户端，Spring Cloud Feign 的出现使得Eureka和Ribbon的使用更为简单；</li><li>Hystrix：断路器，防止某一故障服务被持续访问，实现高可用的微服务架构；</li><li>Config：分布式配置中心，用于配置属性的存储，存储的位置可以为Git仓库、SVN仓库、本地文件等，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新；</li><li>Zuul：服务网关，通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性；</li><li>Bus：消息总线，在不关闭服务的情况下更新我们的配置，当然动态更新服务配置只是消息总线的一个用处，还有很多其他用处。</li></ol><p>只有eureka，zuul，feign，ribbon，hystrix是包含在Netflix组件里的。其他的组件如config，bus是单独开发的。</p><p>Consul、Gateway、Bus、Stream、Sleuth、zipkin和阿里巴巴新的的Nacos、Sentinel、Seata等技术</p><p>SLA：服务水平协议，判断服务的调用、注册情况</p>]]></content>
    
    
    
    <tags>
      
      <tag>职场</tag>
      
      <tag>神州信息金融SBU岗前培训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hibernate和MyBatis的区别</title>
    <link href="/2020/11/27/java/Hibernate_MyBatis/"/>
    <url>/2020/11/27/java/Hibernate_MyBatis/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><p><strong>Hibernate</strong> 是一个开源的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库建立映射关系，是一个全自动的 ORM 框架。</p><ul><li>Hibernate 可以自动生成简单的 SQL 语句，自动执行，对于复杂的 SQL 语句，Hibernate 不需要自己编写，因为它的性能不是很好；</li><li>Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的JaveEE架构中取代CMP，完成数据持久化的重任。</li></ul><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p><strong>MyBatis</strong> 本事 Apache 的一个开源项目 iBatis，是一款优秀的半自动 ORM 框架，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p><ul><li>是一个支持普通的 SQL 查询、存储过程和高级映射的优秀持久层框架；</li><li>可以自动生成简单的 SQL 语句，自动执行；对于复杂的 SQL，需要自己编写，因此具有更好的性能；</li><li>不能自动创建表；</li><li>可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs（普通的 Java 对象）映射成数据库中的记录</li></ul><p><code>MyBatis 相比于 JDBC 的优点</code>：<br>把 SQL 语句从 Java 代码中抽取出来，方便维护。并且修改 SQL 时不需要修改 Java 代码，不用手动设置参数和对结果集进行处理。</p><h2 id="Hibernate-和-MyBatis-的区别"><a href="#Hibernate-和-MyBatis-的区别" class="headerlink" title="Hibernate 和 MyBatis 的区别"></a>Hibernate 和 MyBatis 的区别</h2><ul><li><p>Hibernate 是一个全自动 ORM 框架，功能更加强大，操作更加简单，不需要自己写 SQL，所以不需要掌握数据库相关知识，但性能不好控制，适合中小型项目；</p></li><li><p>MyBatis 是一个半自动 ORM 框架，也封装了很多原生的 SQL，需要了解数据库相关知识，需要自己写 SQL ，性能可控。</p></li></ul><h3 id="开发速度对比"><a href="#开发速度对比" class="headerlink" title="开发速度对比"></a>开发速度对比</h3><p>就开发速度而言，Hibernate 的真正掌握要比 MyBatis 要难。MyBatis 框架相对简单容易上手，但也相对简陋些。个人觉得要用好 MyBatis 还是要先理解好 Hibernate。</p><p>比起二者的开发速度，不仅仅要考虑到二者的特性及性能，还要根据项目需求去考虑究竟哪个更适合项目开发：一个项目中用到的复杂查询基本没有，就是简单的增删改查，这样选择 Hibernate 效率就很快了，因为基本的 SQL 语句都已经被封装好了；但是对于一个大型项目，复杂语句较多，选择 MyBatis 就会快很多，而且语句的管理也比较方便。</p><h3 id="开发工作量的对比"><a href="#开发工作量的对比" class="headerlink" title="开发工作量的对比"></a>开发工作量的对比</h3><p>Hibernate 和 MyBatis 都有相应的代码生成工具，可以生成简单基本的 DAO 层方法。针对高级查询，MyBatis 需要手动编写 SQL 语句，以及 ResultMap。而 Hibernate 有良好的映射机制，开发者无需关心 SQL 的生成以及结果映射，可以更专注于业务流程。</p><h3 id="sql-优化方面"><a href="#sql-优化方面" class="headerlink" title="sql 优化方面"></a>sql 优化方面</h3><p>Hibernate 的查询会将表中的所有字段查询出来，这一点会有性能消耗，当然也可以自己写 SQL 来指定，但这样就破坏了 Hibernate 开发的简洁性。而 MyBatis 的 SQL 是手动编写的，所以可以按需求指定查询的字段。</p><p>Hibernate HQL 语句的调优需要将 SQL 打印出来，而 Hibernate 的 SQL 被很多人嫌弃太丑；MyBatis 的 SQL 是自己手动写的所以调整方便。但 Hibernate 具有自己的日志统计；MyBatis 本身不带日志统计，使用 Log4j 进行日志记录。</p><h3 id="对象管理的对比"><a href="#对象管理的对比" class="headerlink" title="对象管理的对比"></a>对象管理的对比</h3><p>Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理(state management)的功能，使开发者不再需要理会底层数据库系统的细节。</p><ul><li>相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate 采用了更自然的面向对象的视角来持久化 Java 应用中的数据。</li><li>使用 Hibernate 的开发者应该总是关注对象的状态state，不必考虑 SQL 语句的执行，因为这部分细节已经由 Hibernate 掌管妥当，只有开发者子啊进行系统性能调优的时候才需要进行了解。而MyBatis 在这一块没有文档说明，用户需要自己对对象进行详细的管理。</li></ul><h3 id="数据库扩展性计较"><a href="#数据库扩展性计较" class="headerlink" title="数据库扩展性计较"></a>数据库扩展性计较</h3><ul><li>Hibernate 与数据库具体的关联在 XML 文件中，所以 HQL 对具体是用什么数据库并不是很关心；</li><li>MyBatis 由于所有 SQL 都是依赖数据库书写的，所以扩展性、迁移性比较差。</li></ul><h2 id="缓存机制对比"><a href="#缓存机制对比" class="headerlink" title="缓存机制对比"></a>缓存机制对比</h2><h3 id="Hibernate-缓存"><a href="#Hibernate-缓存" class="headerlink" title="Hibernate 缓存"></a>Hibernate 缓存</h3><ul><li>一级缓存是 Session 缓存，利用好一级缓存就需要严格管理好 Session 的生命周期。建议在一个Action 操作中使用一个 Session；</li><li>二级缓存是 SessionFactory 级的缓存或进程级缓存，它可以被所有 Session 共享，它的生命周期伴随着 SessionFactory 的生命周期存亡，除了以内存作为存储介质外，还可以选用硬盘等外部存储设备。SessionFactory 的缓存分为内置缓存和外置缓存：<ul><li>内置缓存中存放的是 SessionFactory 对象的一些集合属性包含的数据（映射元素及预定 SQL 语句等），对于应用程序来说，它是只读的；</li><li>外置缓存中存放的是数据库数据的副本，其作用和一级缓存类似。</li></ul></li></ul><h3 id="MyBatis-缓存"><a href="#MyBatis-缓存" class="headerlink" title="MyBatis 缓存"></a>MyBatis 缓存</h3><p>MyBatis 包含一个非常强大的查询缓存特性，可以方便地配置和定制。MyBatis 3中的缓存实现了很多改进，使得它更加强大且易于配置。</p><p>MyBatis 的一级缓存是在会话（SqlSession）层面进行缓存的。MyBatis 的一级缓存是默认开启的，不需要任何的配置。<br>要开启二级缓存，你需要在你的 SQL 映射文件中添加<code>&lt;cache/&gt;</code>标签，这个简单的语句效果如下：</p><ol><li>映射语句文件中所有的 select 语句将会被缓存；</li><li>映射语句文件中所有的 insert、update 和 delete 语句会刷新缓存；</li><li>缓存会使用 LRU算法（Last Recently Used，最近最少使用）来回收；</li><li>根据时间表（比如：no Flush Interval，没有刷新间隔），缓存不会以任何时间顺序来刷新；</li><li>缓存会存储列表集合或对象（无论查询方法返回什么）的1024个引用；</li><li>缓存会被视为 read/write（可读/可写）的缓存，意味着对象检索不是共享的，而且可以安全地被调用者修改，而不干扰其它调用者或线程所做的潜在修改。</li></ol><p>所有的这些属性都可以通过缓存元素的属性来修改：<code>&lt;cache eviction=”FIFO” flushInterval=”60000″ size=”512″ readOnly=”true”/&gt;</code><br>这个更高级的配置创建了一个 FIFO 缓存，并每隔60秒刷新，存数列表集合或对象的512个引用，而且返回的对象被认为是只读的，因此在不同线程中的调用者之间修改它们会导致冲突。可用的回收策略有：</p><ol><li>LRU（默认）-最近最少使用：移除最长时间不被使用的对象；</li><li>FIFO-先进先出：按对象进入缓存的顺序来移除它们；</li><li>SOFT-软引用：移除基于垃圾回收器状态和软引用规则的对象；</li><li>WEAK-弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li></ol><p><em>参数解析：</em></p><ul><li><strong>eviction</strong>：指定缓存回收策略；</li><li><strong>flushInterval</strong>：指定缓存刷新间隔，可以被设置为任意的正整数，而且它们代表一个合理的毫秒形式的时间段，默认情况是不设置的，也就是没有刷新间隔，缓存仅仅调用语句时才刷新；</li><li><strong>size</strong>：指定缓存引用数目，可以被设置为任意的正整数，要记住你缓存的对象数目和你运行环境的可用内存资源数目，默认值是1024；</li><li><strong>readOnly</strong>：只读，可以被设置为 true 或 false，只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势（可读写的缓存会返回缓存对象的拷贝(通过序列化)。这会慢一些,但是安全,因此默认是 false）；</li></ul><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>Hibernate 和 MyBatis 的二级缓存除了采用系统默认的缓存机制外，预留了集成第三方缓存的接口，都可以通过实现你自己的缓存或为其它第三方缓存方案，创建适配器来完全覆盖缓存行为。</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul><li>Hibernate 的二级缓存配置在 SessionFactory 生成的配置文件中进行详细配置，然后再在具体的数据库表—Java对象映射中配置是那种缓存；</li><li>MyBatis 的二级缓存配置都是在每个具体的数据库表—Java对象映射中进行详细配置，这样针对不同的表可以使用不用的缓存机制，并且 MyBatis 可以在命名空间中共享相同的缓存配置和实例，通过 <code>Cache-ref</code> 来实现。</li></ul><p><font color=#FF000><em>两者比较：</em></font></p><ul><li>因为 Hibernate 对查询对象有着良好的管理机制，用户无需关心 SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示；</li><li>MyBatis在这方面使用二级缓存是需要特别小心，如果不能完全确定数据更新操作波及的范围，就要避免 Cache 的使用，否则脏数据的出现会给系统的正常运行带来很大的隐患。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="两个框架的相同点"><a href="#两个框架的相同点" class="headerlink" title="两个框架的相同点"></a>两个框架的相同点</h3><p>Hibernate 和 MyBatis 都可以通过 SessionFactoryBuilder 由 XML 配置文件生成 SessionFactory，然后由 SessionFactory 生成 Session，最后由 Session 来开启执行事务和 SQL 语句。</p><ul><li>其中 SessionFactoryBuilder、SessionFactory、Session 的生命周期都差不多；</li><li>Hibernate 和 MyBatis 都支持 JDBC 和 JTA（Java Transaction API：Java 事务编程接口） 事务处理。</li></ul><h3 id="MyBatis-优势"><a href="#MyBatis-优势" class="headerlink" title="MyBatis 优势"></a>MyBatis 优势</h3><ul><li>MyBatis 可以进行更为细致的 SQL 优化，可以减少查询字段；</li><li>MyBatis 容易掌握，而 Hibernate 门槛较高。</li></ul><h3 id="Hibernate-优势"><a href="#Hibernate-优势" class="headerlink" title="Hibernate 优势"></a>Hibernate 优势</h3><ul><li>Hibernate 的 DAO 层开发比 MyBatis 简单，MyBatis 需要维护 SQL 和结果映射；</li><li>Hibernate 对对象的维护和缓存要比 MyBatis 好，对 CRUD 的对象的维护要方便；</li><li>Hibernate 数据库移植性很好，而 MyBatis 的数据库移植性不好，因为不同的数据库要写不同的 SQL；</li><li>Hibernate 有更好的二级缓存机制，可以使用第三方缓存，而 MyBatis 本身提供的缓存机制不佳；</li></ul><h2 id="MyBatis中-和-的区别"><a href="#MyBatis中-和-的区别" class="headerlink" title="MyBatis中#{}和${}的区别"></a>MyBatis中#{}和${}的区别</h2><p><code>#&#123;&#125;</code> 是预编译处理，<code>$&#123;&#125;</code> 是字符串替换：</p><ul><li>MyBatis 在处理 #{} 时，会把 SQL 中的 #{} 替换为 ?(SQL占位符)，调用 PreparedStatement 的 set 方法来赋值；</li><li>MyBatis 在处理 ${} 时，就是把 ${} 替换为变量的值；</li><li><font color=#FF000>重点</font>：#{} 的存在与 JDBC 中出现 PreparedStatement 对象一样，都是为了防止 SQL 注入，提高系统安全性。</li></ul><h2 id="MyBatis中实体类的属性名和数据库表的字段名不一样怎么办？"><a href="#MyBatis中实体类的属性名和数据库表的字段名不一样怎么办？" class="headerlink" title="MyBatis中实体类的属性名和数据库表的字段名不一样怎么办？"></a>MyBatis中实体类的属性名和数据库表的字段名不一样怎么办？</h2><ol><li>通过在<code>mapper.xml</code>查询的 SQL 语句中使用 AS 关键字（也可以省略）定义字段的别名，让其与实体类的属性名一致：<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”select”</span> <span class="hljs-attr">parametertype</span>=<span class="hljs-string">”int”</span> <span class="hljs-attr">resultetype</span>=<span class="hljs-string">”com.soldier.xxxEntity”</span>&gt;</span>   select order_id orderId, order_no orderNo ,order_price orderPrice form orders where order_id=#&#123;id&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li><li>通过在<code>mapper.xml</code>中使用 <resultMap/> 标签来映射数据库表与实体类的对应关系：<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">”com.soldier.xxxEntity”</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”orderResultMap”</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">!–用id属性来映射主键字段–</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">”orderId”</span> <span class="hljs-attr">column</span>=<span class="hljs-string">”order_id”</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span> = <span class="hljs-string">“orderNo”</span> <span class="hljs-attr">column</span> =<span class="hljs-string">”order_no”/</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">”orderPrice”</span> <span class="hljs-attr">column</span>=<span class="hljs-string">”order_price”/</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">reslutMap</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”select”</span> <span class="hljs-attr">parametertype</span>=<span class="hljs-string">”int”</span> <span class="hljs-attr">resulteMap</span>=<span class="hljs-string">”orderResultMap”</span>&gt;</span>   select order_id, order_no, order_price form orders where order_id=#&#123;id&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li></ol><h2 id="简述Mybatis的插件运行原理，以及如何编写一个插件"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件"></a>简述Mybatis的插件运行原理，以及如何编写一个插件</h2><p><strong>答：</strong> MyBatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor这四个接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke() 方法，当然只会拦截那些你指定需要拦截的方法。</p><p><strong>编写插件：</strong> 实现 MyBatis 的 Interceptor 接口并复写 intercept() 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，还要在配置文件中配置编写好的插件。</p><h2 id="MyBatis是如何进行分页的？分页插件的原理是什么？"><a href="#MyBatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="MyBatis是如何进行分页的？分页插件的原理是什么？"></a>MyBatis是如何进行分页的？分页插件的原理是什么？</h2><p>MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页。可以在 SQL 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><h2 id="Hibernate-的工作原理"><a href="#Hibernate-的工作原理" class="headerlink" title="Hibernate 的工作原理"></a>Hibernate 的工作原理</h2><ol><li>读取并解析配置文件；</li><li>读取并解析映射信息，创建 SessionFactory；</li><li>打开 Session；</li><li>创建事务 Transaction；</li><li>持久化操作；</li><li>提交事务；</li><li>关闭 Session；</li><li>关闭 SessionFactory。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Java面试题</tag>
      
      <tag>Hibernate</tag>
      
      <tag>MyBatis， 框架</tag>
      
      <tag>ORM框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue框架面试总结</title>
    <link href="/2020/11/25/java/Vue/"/>
    <url>/2020/11/25/java/Vue/</url>
    
    <content type="html"><![CDATA[<h2 id="vuex的作用？"><a href="#vuex的作用？" class="headerlink" title="vuex的作用？"></a>vuex的作用？</h2><p>vuex 是一个专门为 vue.js 应用程序开发的状态管理模式，可以帮助我们管理共享状态，也就是<code>管理全局变量</code>。</p><p>vuex 使用一个 store 对象管理应用的状态，一个 store包括：state、getter、mutation、action、modules 五个属性</p><ul><li><strong>state</strong>：意为‘状态’，是 vuex 状态管理的数据源；</li><li><strong>getter</strong>：作用与 filters 有一些相似，可以将 state 进行过滤后输出；</li><li><strong>mutation</strong>：是 vuex 中改变state 的唯一途径，并且只能同步操作；</li><li><strong>action</strong>：一些对 state 的异步操作可以放在 action 中，并通过在 action 中提交 mutation 变更状态；</li><li><strong>modules</strong>：模块化vuex，可以让每一个模块拥有自己的 state、mutation、action、getters，使得结构非常清晰，方便管理。</li></ul><p>我们可以在组件中触发 action，action 则会提交 mutation，mutation 会对 state 进行修改，组件再根据 state、getter 渲染页面。</p><h2 id="vue-中路由拦截器的作用？"><a href="#vue-中路由拦截器的作用？" class="headerlink" title="vue 中路由拦截器的作用？"></a>vue 中路由拦截器的作用？</h2><p>作用是：路由拦截、权限设置。</p><p>例如：当用户没有登录或后台 token 失效时就会跳转到登录页面，用到的字段<code>requireAuth:true</code>。</p><pre><code class="hljs vue">router.beforeEach((to,from,next)&#x3D;&gt;&#123;    if(to.path&#x3D;&#x3D;&#39;&#x2F;login&#39; || localStorage.getItem(&#39;token&#39;))&#123;        next();    &#125;else&#123;        alert(&#39;请重新登录&#39;);        next(&#39;&#x2F;login&#39;);    &#125;&#125;)</code></pre><h2 id="axios-的作用？"><a href="#axios-的作用？" class="headerlink" title="axios 的作用？"></a>axios 的作用？</h2><p><code>axios</code>：是由 promise 封装的一个 http 的库，相当于 vue 中的 ajax，用于向后台发送请求。特点是：</p><ul><li>从浏览器中创建 XMLHttpRequests；</li><li>从 node.js 中创建 http 请求；</li><li>支持 Promise API；</li><li>拦截请求和响应；</li><li>转换请求数据和响应数据；</li><li>取消请求；</li><li>自动转换 json 数据；</li><li>客户端支持防御 XSRF 攻击。</li></ul><p><code>Promise</code>： 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了 Promise。<br>Promise 的本质是分离异步数据获取和业务。</p><p>我们可以使用 Promise 配合 axios 实现拦截器：</p><ol><li>请求拦截器<pre><code class="hljs vuejs">axios.interceptors.request.use(function(config)&#123;    return config;&#125;,function(error)&#123;    return Promise.reject(error);&#125;);</code></pre></li><li>响应拦截器<pre><code class="hljs vuejs">axios.interceptors.response.use(function(response)&#123;    return response;&#125;,function(error)&#123;    return Promise.reject(error);&#125;);</code></pre></li></ol><h2 id="列举-vue-的常见指令"><a href="#列举-vue-的常见指令" class="headerlink" title="列举 vue 的常见指令"></a>列举 vue 的常见指令</h2><ol><li><code>&#123;&#123;&#125;&#125;</code>：文本插值<pre><code class="hljs vue">&lt;div id&#x3D;&quot;app&quot;&gt;    &#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;</code></pre></li><li><code>v-bind</code>：DOM 属性绑定<pre><code class="hljs vue">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;span v-bind:title&#x3D;&#39;message&#39;&gt;        鼠标悬停几秒钟查看此处动态绑定的提示信息    &lt;&#x2F;span&gt;&lt;&#x2F;div&gt;</code></pre></li><li><code>v-on</code>：绑定一个事件监听器<pre><code class="hljs vue">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;button v-on:click&#x3D;&#39;deleteHandler&#39;&gt;删除&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;</code></pre></li><li><code>v-model</code>：实现表单输入和应用状态的双向数据绑定<pre><code class="hljs vue">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt;    &lt;input v-model&#x3D;&#39;message&#39;&gt;&lt;&#x2F;div&gt;</code></pre></li><li><code> v-if 和 v-else</code>：控制元素的显示，动态的向DOM树内添加或者删除DOM元素（条件不成立时不会出现代码）<pre><code class="hljs vue">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;p v-if&#x3D;&#39;isStudent&#39;&gt;我是学生&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</code></pre></li><li><code>v-show</code>：控制元素的显示，本质就是通过设置 css 中的 display 设置为 none，控制隐藏（条件不成立时会出现代码）<pre><code class="hljs vue">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;p v-show&#x3D;&#39;isStudent&#39;&gt;我是学生&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</code></pre></li><li><code>v-for</code>：列表渲染<pre><code class="hljs vue">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;template v-for&#x3D;&quot;stu in studentList&quot;&gt;        &lt;span v-text&#x3D;&quot;stu.name&quot;&gt;&lt;&#x2F;span&gt;    &lt;&#x2F;template&gt;&lt;&#x2F;div&gt;</code></pre></li></ol><h2 id="对于-MVVM-的理解"><a href="#对于-MVVM-的理解" class="headerlink" title="对于 MVVM 的理解"></a>对于 MVVM 的理解</h2><p>Vue 是一个基于 MVVM（Model-View-ViewModel）模式实现的轻量级的渐进式前端框架，它提供了一种帮助开发者快速构建并开发前端项目的新的思维模式。</p><ul><li><strong>Model</strong>：代表数据模型，也可以在 Model 中定于数据修改和操作的业务逻辑；</li><li><strong>View</strong>：代表 UI 组件，它负责将数据模型转化为 UI 展示出来；</li><li><strong>ViewModel</strong>：监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View。</li></ul><p>ViewModel 和 Model 实现双向数据绑定。</p><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><ol><li>什么是 Vue 的生命周期？<br><code>答：</code>Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、编译模板、挂载DOM &rarr; 渲染、更新 &rarr; 渲染、销毁等一系列过程，称之为 Vue 的生命周期。</li><li>Vue 生命周期的作用是什么？<br><code>答：</code>它的生命周期中有多个事件钩子，让我们在控制整个 Vue 实例的过程时更容易形成好的逻辑。</li><li>Vue 生命周期总共有几个阶段？<br><code>答：</code>它可以总共分为8个阶段：创建前、后 &rarr; 转入前、后 &rarr; 更新前、后 &rarr; 销毁前、后。</li><li>第一次页面加载会触发哪几个钩子？<br><code>答：</code>会触发beforeCreate、created、beforeMount、mounted。</li><li>DOM 渲染在哪个周期中就已经完成？<br><code>答：</code>DOM 渲染在 mounted 中就已经完成了。</li></ol><h2 id="Vue-实现数据双向绑定的原理是什么？"><a href="#Vue-实现数据双向绑定的原理是什么？" class="headerlink" title="Vue 实现数据双向绑定的原理是什么？"></a>Vue 实现数据双向绑定的原理是什么？</h2><p><code>答：</code>Object.defineProperty（）。采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。</p><h2 id="Vue-组件间的参数传递"><a href="#Vue-组件间的参数传递" class="headerlink" title="Vue 组件间的参数传递"></a>Vue 组件间的参数传递</h2><ol><li>父组件与子组件传值<br> 1.1 父组件传给子组件：子组件通过 <code>props 方法</code>接受数据;<br> 1.2 子组件传给父组件：<code>$emit 方法</code>传递参数</li><li>非父子组件间的数据传递，兄弟组件传值<br>eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。）</li></ol><h2 id="怎么定义-vue-router-的动态路由-怎么获取传过来的值"><a href="#怎么定义-vue-router-的动态路由-怎么获取传过来的值" class="headerlink" title="怎么定义 vue-router 的动态路由? 怎么获取传过来的值"></a>怎么定义 vue-router 的动态路由? 怎么获取传过来的值</h2><p>在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。</p><h2 id="vue常用的修饰符？"><a href="#vue常用的修饰符？" class="headerlink" title="vue常用的修饰符？"></a>vue常用的修饰符？</h2><ul><li>.prevent: 提交事件不再重载页面；</li><li>.stop: 阻止单击事件冒泡；</li><li>.self: 当事件发生在该元素本身而不是子元素的时候会触发；</li><li>.capture: 事件侦听，事件发生的时候会调用</li></ul><h2 id="vue-js的两个核心是什么？"><a href="#vue-js的两个核心是什么？" class="headerlink" title="vue.js的两个核心是什么？"></a>vue.js的两个核心是什么？</h2><p>数据驱动、组件系统</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Java面试题</tag>
      
      <tag>Vue， 框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法学习笔记</title>
    <link href="/2020/11/24/java/Sort/"/>
    <url>/2020/11/24/java/Sort/</url>
    
    <content type="html"><![CDATA[<h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p><strong>提取每一个排序算法公共部分作为父类的属性</strong>：<br>待排序的元素需要实现 Java 的 Comparable 接口，该接口有 compareTo() 方法，可以用它来判断两个元素的大小关系。<br>使用辅助函数 less() 和 swap() 来进行比较的交换的操作，使得代码的可读性和可移植性更好。</p><p>排序算法的成本模型是比较和交换的次数。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sort</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;    <span class="hljs-comment">// 具体排序实现</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] nums)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 比较</span><span class="hljs-comment">     * 小于返回true；大于返回false</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">less</span><span class="hljs-params">(T v, T w)</span> </span>&#123;        <span class="hljs-comment">// compareTo--&gt;小于返回-1；等于返回0；大于返回1</span>        <span class="hljs-keyword">return</span> v.compareTo(w) &lt; <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 交换</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T[] a, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        T t = a[i];        a[i] = a[j];        a[j] = t;    &#125;&#125;</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><font color=#FF000><strong>概念</strong></font>：从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p><p>选择排序需要 ~N<sup>2</sup>/2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。</p><p><strong>实现</strong>：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Selection</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Sort</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] nums)</span> </span>&#123;        <span class="hljs-comment">// 数组长度</span>        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n -<span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-comment">// 取数组第1个到 n-1 个元素</span>            <span class="hljs-keyword">int</span> min = i;            <span class="hljs-comment">// 与子数组进行比较</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;                <span class="hljs-comment">// 获取最小元素下标</span>                <span class="hljs-keyword">if</span> (less(nums[j], nums[min])) min = j;            &#125;            <span class="hljs-comment">// 把最小的元素放到前面</span>            swap(nums, i, min);        &#125;    &#125;&#125;</code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><font color=#FF000><strong>概念</strong></font>：从左到右不断比较相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。在一轮循环中，如果没有发生变化，那么说明数组已经是有序的，此时可以直接退出。</p><p><strong>实现</strong>：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bubble</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Sort</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] nums)</span> </span>&#123;        <span class="hljs-comment">// 数组长度</span>        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">boolean</span> isSorted = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// 取游标i：从最后一个元素取到第二个元素，游标后的元素已经有序</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span> &amp;&amp; !isSorted; i--) &#123;            <span class="hljs-comment">// 每取一次都默认当前数组已经有序</span>            isSorted = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">// 只比较游标前的元素</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;                <span class="hljs-comment">// 某相邻的两个元素不是有序</span>                <span class="hljs-keyword">if</span> (less(nums[j + <span class="hljs-number">1</span>], nums[j])) &#123;                    <span class="hljs-comment">// 表明这个数组还不是有序的</span>                    isSorted = <span class="hljs-keyword">false</span>;                    <span class="hljs-comment">// 交换相邻两个元素位置</span>                    swap(nums, j, j + <span class="hljs-number">1</span>);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><font color=#FF000><strong>概念</strong></font>：每次都将当前元素插入到左侧以及排序的数组中，使得插入之后左侧数组依然有序。</p><p>对于数值{3, 5, 2, 4, 1}，它具有一下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少1，因此插入排序需要交换的次数为逆序数量。</p><p>插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要的交换次数也就较少，时间复杂度较低。</p><ul><li>平均情况下插入排序需要 ~N2/4 比较以及 ~N2/4 次交换；</li><li>最坏的情况下需要 ~N2/2 比较以及 ~N2/2 次交换，最坏的情况是数组是倒序的；</li><li>最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。</li></ul><p><strong>实现</strong>：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Insertion</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Sort</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] nums)</span> </span>&#123;        <span class="hljs-comment">// 数组长度</span>        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-comment">// 游标i：从第二个元素开始取</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            <span class="hljs-comment">// 从游标处倒着比较到第1个元素，比较并交换相邻两个元素；有序时直接跳过</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span> &amp;&amp; less(nums[j], nums[j - <span class="hljs-number">1</span>]); j--) &#123;                swap(nums, j, j - <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><font color=#FF000><strong>概念</strong></font>：对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过<strong>交换不相邻的元素</strong>，每次可以将逆序数量减少大于1.</p><p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减少 h，最后令 h=1，就可以使得整个数组是有序的。<br><img src="/resource/img/java/Sort_shell.png"></p><p><strong>实现</strong>：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shell</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Sort</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] nums)</span> </span>&#123;        <span class="hljs-comment">// 数组长度</span>        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-comment">// 计算递增序列h：1, 4, 13, 40, 121, 364, 1093...(间隔为1时是插入排序)</span>        <span class="hljs-keyword">int</span> h = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (h &lt; n / <span class="hljs-number">3</span>) &#123;            h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 通过while循环，每次减少3倍序列h的值</span>        <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 使用插入排序对间隔 h 的数组进行排序</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h; i &lt; n; i++) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= h &amp;&amp; less(nums[j], nums[j - h]) ; j -= h) &#123;                    swap(nums, j, j-h);                &#125;            &#125;            h /= <span class="hljs-number">3</span>;        &#125;    &#125;&#125;</code></pre><p>希尔排序的运行时间达不到平方级别，使用<code>递增序列 1, 4, 13, 40, ...</code> 的希尔排序所需要的比较次数不会超过 <code>n 的若干倍</code>乘于 <code>递增序列的长度</code>。后面介绍的高级排序算法只会比希尔排序快两倍左右。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><font color=#FF000><strong>概念</strong></font>：是将数组分成两部分，分别进行排序，然后归并起来。<br><img src="/resource/img/java/Sort_merge.png"></p><h3 id="1-公共的归并方法"><a href="#1-公共的归并方法" class="headerlink" title="1.公共的归并方法"></a>1.公共的归并方法</h3><p><strong>归并方法</strong>将数组中两个已经排序的部分归并成一个。它基础自约定Sort类，是两种类型的归并排序的父类，内含公共的合并方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSort</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Sort</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">// 辅助数组</span>    <span class="hljs-keyword">protected</span> T[] aux;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将数组中两个已经排序的部分归并成一个，l和h表明起始位置</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums  被操纵数组</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> l     数组下标开始位置</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m     数组中间下标</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> h     数组下标结束位置</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(T[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> h)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = m+<span class="hljs-number">1</span>;        <span class="hljs-comment">// 将数据复制到辅助数组</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= h; k++) &#123;            aux[k] = nums[k];        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= h; k++) &#123;            <span class="hljs-keyword">if</span> (i &gt; m) &#123;                nums[k] = aux[j++];            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; h) &#123;                nums[k] = aux[i++];            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aux[i].compareTo(aux[j]) &lt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// compareTo--&gt;小于返回-1；等于返回0；大于返回1</span>                nums[k] = aux[i++]; <span class="hljs-comment">// 先进行这一步，保证稳定性</span>            &#125; <span class="hljs-keyword">else</span> &#123;                nums[k] = aux[j++];            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="2-自顶向下的归并排序"><a href="#2-自顶向下的归并排序" class="headerlink" title="2.自顶向下的归并排序"></a>2.自顶向下的归并排序</h3><p>将一个大数组分成两个小数组去求解。</p><p>因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为：O(NlogN)。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Up2DownMergeSort</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">MergeSort</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] nums)</span> </span>&#123;        aux = (T[]) <span class="hljs-keyword">new</span> Comparable[nums.length];        sort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 排序</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums  被操纵数组</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> l     数组下标开始位置</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> h     数组下标结束位置</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> h)</span> </span>&#123;        <span class="hljs-keyword">if</span> (h &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-comment">// 计算当前数组中间下标</span>        <span class="hljs-keyword">int</span> mid = <span class="hljs-number">1</span> + (h-<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-comment">// 递归：排序左子数组</span>        sort(nums, l, mid);        <span class="hljs-comment">// 递归：排序右子数组</span>        sort(nums, mid + <span class="hljs-number">1</span>, h);        <span class="hljs-comment">// 根据中间下标，合并左右子数组</span>        merge(nums, l ,mid, h);    &#125;&#125;</code></pre><h3 id="3-自底向上的归并排序"><a href="#3-自底向上的归并排序" class="headerlink" title="3.自底向上的归并排序"></a>3.自底向上的归并排序</h3><p>先归并那些微型数组，然后成对归并得到的微型数组。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Down2UpMergeSort</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">MergeSort</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        aux = (T[]) <span class="hljs-keyword">new</span> Comparable[n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sz = <span class="hljs-number">1</span>; sz &lt; n; sz += sz) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>; lo &lt; n - sz; lo += sz + sz) &#123;                merge(nums, lo, lo + sz - <span class="hljs-number">1</span>, Math.min(lo + sz + sz - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>));            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="1-基本算法"><a href="#1-基本算法" class="headerlink" title="1.基本算法"></a>1.基本算法</h3><p><font color=#FF000><strong>概念</strong></font>：</p><ul><li>归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；</li><li>快速排序通过一个切分元素将数组分为两个子数组，左子数组小于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</li></ul><p><img src="/resource/img/java/Sort_quick.png"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Sort</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] nums)</span> </span>&#123;        shuffle(nums);        sort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> h)</span> </span>&#123;        <span class="hljs-keyword">if</span> (h &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">int</span> j = partition(nums, l, h);        sort(nums, l, j - <span class="hljs-number">1</span>);        sort(nums, j + <span class="hljs-number">1</span>, h);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(T[] nums)</span> </span>&#123;        List&lt;Comparable&gt; list = Arrays.asList(nums);        Collections.shuffle(list);        list.toArray(nums);    &#125;&#125;</code></pre><h3 id="2-切分"><a href="#2-切分" class="headerlink" title="2.切分"></a>2.切分</h3><p>将 a[l] 作为切分元素，然后从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。不断进行这个过程，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[l] 和 a[j] 交换位置。<br><img src="/resource/img/java/Sort_partition.gif"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(T[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> h)</span> </span>&#123;    <span class="hljs-keyword">int</span> i = l, j = h + <span class="hljs-number">1</span>;    T v = nums[l];    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        <span class="hljs-keyword">while</span> (less(nums[++i], v) &amp;&amp; i != h) ;        <span class="hljs-keyword">while</span> (less(v, nums[--j]) &amp;&amp; j != l) ;        <span class="hljs-keyword">if</span> (i &gt;= j)            <span class="hljs-keyword">break</span>;        swap(nums, i, j);    &#125;    swap(nums, l, j);    <span class="hljs-keyword">return</span> j;&#125;</code></pre><h3 id="3-性能分析"><a href="#3-性能分析" class="headerlink" title="3.性能分析"></a>3.性能分析</h3><p>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。</p><p>快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 C<sub>N</sub>=2C<sub>N/2</sub>+N，复杂度为 O(NlogN)。</p><p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N<sup>2</sup>/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p><h3 id="4-算法改进"><a href="#4-算法改进" class="headerlink" title="4.算法改进"></a>4.算法改进</h3><h4 id="4-1-切换到插入排序"><a href="#4-1-切换到插入排序" class="headerlink" title="4.1 切换到插入排序"></a>4.1 切换到插入排序</h4><p>因为快速排序在小数组中也会递归调用自己，<code>对于小数组，插入排序比快速排序的性能更好</code>，因此在小数组中可以切换到插入排序。</p><h4 id="4-2-三数居中"><a href="#4-2-三数居中" class="headerlink" title="4.2 三数居中"></a>4.2 三数居中</h4><p>最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取3个元素，并将大小居中的元素作为切分元素。</p><h4 id="4-3-三向切分的快速排序"><a href="#4-3-三向切分的快速排序" class="headerlink" title="4.3 三向切分的快速排序"></a>4.3 三向切分的快速排序</h4><p>对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。</p><p>三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreeWayQuickSort</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">QuickSort</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> h)</span> </span>&#123;        <span class="hljs-keyword">if</span> (h &lt;= l) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> lt = l, i = l + <span class="hljs-number">1</span>, gt = h;        T v = nums[l];        <span class="hljs-keyword">while</span> (i &lt;= gt) &#123;            <span class="hljs-keyword">int</span> cmp = nums[i].compareTo(v);            <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>) &#123;                swap(nums, lt++, i++);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123;                swap(nums, i, gt--);            &#125; <span class="hljs-keyword">else</span> &#123;                i++;            &#125;        &#125;        sort(nums, l, lt - <span class="hljs-number">1</span>);        sort(nums, gt + <span class="hljs-number">1</span>, h);    &#125;&#125;</code></pre><h3 id="5-基于切分的快速选择算法"><a href="#5-基于切分的快速选择算法" class="headerlink" title="5.基于切分的快速选择算法"></a>5.基于切分的快速选择算法</h3><p>快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。</p><p>可以利用这个特性找出数组的第 k 个元素。</p><p>该算法是线性级别的，假设每次能将数组二分，那么比较的总次数为 (N+N/2+N/4+..)，直到找到第 k 个元素，这个和显然小于 2N。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">select</span><span class="hljs-params">(T[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (h &gt; l) &#123;        <span class="hljs-keyword">int</span> j = partition(nums, l, h);        <span class="hljs-keyword">if</span> (j == k) &#123;            <span class="hljs-keyword">return</span> nums[k];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; k) &#123;            h = j - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            l = j + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> nums[k];&#125;</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="1-堆"><a href="#1-堆" class="headerlink" title="1.堆"></a>1.堆</h3><p>堆中某个节点的值总是大于等于或小于其子节点的值，并且堆是一颗完全二叉树。</p><p>堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1.这里不使用数组索引为0的位置，是为了更清晰地描述节点的位置关系。<br><img src="/resource/img/java/Sort_heap.png"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;        <span class="hljs-keyword">private</span> T[] heap;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> maxN)</span> </span>&#123;        <span class="hljs-keyword">this</span>.heap = (T[]) <span class="hljs-keyword">new</span> Comparable[maxN + <span class="hljs-number">1</span>];    &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> n;    &#125;        <span class="hljs-comment">// 比较：小于返回true；大于等于返回false</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">less</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">return</span> heap[i].compareTo(heap[j]) &lt; <span class="hljs-number">0</span>;    &#125;        <span class="hljs-comment">// 交换</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        T t = heap[i];        heap[i] = heap[j];        heap[j] = t;    &#125;&#125;</code></pre><h3 id="2-上浮和下沉"><a href="#2-上浮和下沉" class="headerlink" title="2.上浮和下沉"></a>2.上浮和下沉</h3><p>在堆中，当一个节点比父节点大，那么需要交换这两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。<br><img src="/resource/img/java/Sort_heap_swim.gif"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">1</span> &amp;&amp; less(k /<span class="hljs-number">2</span>, k)) &#123;        swap(k /<span class="hljs-number">2</span>, k);        k = k /<span class="hljs-number">2</span>;    &#125;&#125;</code></pre><p>类似的，当一个节点比子节点小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。<br><img src="/resource/img/java/Sort_heap_sink.gif"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span> * k &lt;= n) &#123;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> *k;        <span class="hljs-keyword">if</span> (j &lt; n &amp;&amp; less(j, j+<span class="hljs-number">1</span>))            j++;        <span class="hljs-keyword">if</span> (!less(k, j))             <span class="hljs-keyword">break</span>;        swap(k, j);        k = j;    &#125;&#125;</code></pre><h3 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3.插入元素"></a>3.插入元素</h3><p>将新元素放到数组末尾，然后上浮到合适位置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Comparable v)</span> </span>&#123;    heap[++n] = (T) v;    swim(n);&#125;</code></pre><h3 id="4-删除最大元素"><a href="#4-删除最大元素" class="headerlink" title="4.删除最大元素"></a>4.删除最大元素</h3><p>从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适位置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">delMax</span><span class="hljs-params">()</span> </span>&#123;    T max = heap[<span class="hljs-number">1</span>];    swap(<span class="hljs-number">1</span>, n--);    heap[n + <span class="hljs-number">1</span>] = <span class="hljs-keyword">null</span>;    sink(<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> max;&#125;</code></pre><h3 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h3><p>把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。</p><h4 id="5-1构建堆"><a href="#5-1构建堆" class="headerlink" title="5.1构建堆"></a>5.1构建堆</h4><p>无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。</p><h4 id="5-2交换堆顶元素与最后一个元素"><a href="#5-2交换堆顶元素与最后一个元素" class="headerlink" title="5.2交换堆顶元素与最后一个元素"></a>5.2交换堆顶元素与最后一个元素</h4><p>交换之后需要进行下沉操作维持堆的有序状态。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Sort</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 数组第 0 个位置不能有元素</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = n / <span class="hljs-number">2</span>; k &gt;= <span class="hljs-number">1</span>; k--)            sink(nums, k, n);        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>) &#123;            swap(nums, <span class="hljs-number">1</span>, n--);            sink(nums, <span class="hljs-number">1</span>, n);        &#125;    &#125;    <span class="hljs-comment">// 下沉</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(T[] nums, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span> * k &lt;= n) &#123;            <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * k;            <span class="hljs-keyword">if</span> (j &lt; n &amp;&amp; less(nums, j, j + <span class="hljs-number">1</span>))                j++;            <span class="hljs-keyword">if</span> (!less(nums, k, j))                <span class="hljs-keyword">break</span>;            swap(nums, k, j);            k = j;        &#125;    &#125;    <span class="hljs-comment">// 比较：小于返回true；大于等于返回false</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">less</span><span class="hljs-params">(T[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">return</span> nums[i].compareTo(nums[j]) &lt; <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><h3 id="6-分析"><a href="#6-分析" class="headerlink" title="6.分析"></a>6.分析</h3><ul><li>一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。</li><li>对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。</li><li>堆排序是一种原地排序，没有利用额外的空间。</li><li>现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="1-排序算法的比较"><a href="#1-排序算法的比较" class="headerlink" title="1.排序算法的比较"></a>1.排序算法的比较</h3><table><thead><tr><th align="center">算法</th><th align="center">稳定性</th><th align="center">时间复杂度</th><th align="center">空间复杂度</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">选择排序</td><td align="center">x</td><td align="center">N<sup>2</sup></td><td align="center">1</td><td align="center"></td></tr><tr><td align="center">冒泡排序</td><td align="center">&radic;</td><td align="center">N<sup>2</sup></td><td align="center">1</td><td align="center"></td></tr><tr><td align="center">插入排序</td><td align="center">&radic;</td><td align="center">N ~ N<sup>2</sup></td><td align="center">1</td><td align="center">时间复杂度和初始顺序有关</td></tr><tr><td align="center">希尔排序</td><td align="center">x</td><td align="center">N 的若干倍乘于递增序列的长度</td><td align="center">1</td><td align="center">改进版的插入排序</td></tr><tr><td align="center">快速排序</td><td align="center">x</td><td align="center">NlogN</td><td align="center">logN</td><td align="center"></td></tr><tr><td align="center">三向切分的快速排序</td><td align="center">x</td><td align="center">N ~ NlogN</td><td align="center">logN</td><td align="center">适用于大量重复元素的数组</td></tr><tr><td align="center">归并排序</td><td align="center">&radic;</td><td align="center">NlogN</td><td align="center">N</td><td align="center"></td></tr><tr><td align="center">堆排序</td><td align="center">x</td><td align="center">NlogN</td><td align="center">1</td><td align="center">无法利用局部性原理</td></tr></tbody></table><h3 id="2-Java-的排序算法实现"><a href="#2-Java-的排序算法实现" class="headerlink" title="2.Java 的排序算法实现"></a>2.Java 的排序算法实现</h3><p>Java 主要排序方法为 <code>java.util.Arrays.sort()</code>，对原始数据类型使用<font color=#FF000>三向切分的快速排序</font>，对于引用类型使用<font color=#FF000>归并排序</font>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习笔记及面试题</title>
    <link href="/2020/11/20/java/MySQL/"/>
    <url>/2020/11/20/java/MySQL/</url>
    
    <content type="html"><![CDATA[<h2 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h2><h3 id="B-Tree原理"><a href="#B-Tree原理" class="headerlink" title="B+ Tree原理"></a>B+ Tree原理</h3><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h4><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p><p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现的，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ Tree 中，一个节点中的key从左到右非递减列，如果某个指针的左右相邻 key 分别是 key<sub>i</sub> 和 key<sub>i+1</sub>，且不为null，则该指针指向节点的所有 key 大于等于 key<sub>i</sub> 且小于等于 key<sub>i+1</sub>.<br><img src="/resource/img/java/B+Tree%E5%8E%9F%E7%90%86.png"></p><h4 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h4><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p><p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p><h4 id="3-与红黑树的比较"><a href="#3-与红黑树的比较" class="headerlink" title="3.与红黑树的比较"></a>3.与红黑树的比较</h4><p>红黑树等平衡树可以用来实现索引，但是文件系统及数据库普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ Tree 访问磁盘数据有更高的性能。</p><p>（一）B+ Tree 有更低的树高<br>平衡树的树高 O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。红黑树的出度d为2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p><p>（二）磁盘访问原理<br>操作系统一般将内存和磁盘分割成固定大小的快，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p><p>如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为去物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ Tree相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，使用 B+ Tree 更适合磁盘数据的读取。</p><p>（三）磁盘预读特性<br>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h3 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h3><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具备不同的索引类型和实现。</p><h4 id="1-B-Tree-索引"><a href="#1-B-Tree-索引" class="headerlink" title="1.B+ Tree 索引"></a>1.B+ Tree 索引</h4><p>是大多数 MySQL 存储引擎的默认索引类型。</p><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p><p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引列，多个索引列共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB 的 B+ Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因此无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。<br><img src="/resource/img/java/B+Tree%E7%B4%A2%E5%BC%951.png"></p><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查询时，需要先查找主键值，然后再到主索引中进行查找。<br><img src="/resource/img/java/B+Tree%E7%B4%A2%E5%BC%952.png"></p><h4 id="2-哈希索引"><a href="#2-哈希索引" class="headerlink" title="2.哈希索引"></a>2.哈希索引</h4><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+　Ｔｒｅｅ　索引之上再创建一个哈希索引，这样就让　Ｂ＋　Ｔｒｅｅ　索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h4 id="3-全文索引"><a href="#3-全文索引" class="headerlink" title="3.全文索引"></a>3.全文索引</h4><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB存储引擎在 MySQL5.6.4 版本中也开始支持全文索引。</p><h4 id="4-空间数据索引"><a href="#4-空间数据索引" class="headerlink" title="4.空间数据索引"></a>4.空间数据索引</h4><p>MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>注意：必须使用 GIS 相关的函数来维护数据。</p><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1.独立的列"></a>1.独立的列</h4><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。<br>例如下面的查询不能使用<code>actor_id</code>列的索引：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> actor_id <span class="hljs-keyword">FROM</span> sakila.actor <span class="hljs-keyword">WHERE</span> actor_id + <span class="hljs-number">1</span> = <span class="hljs-number">5</span>;</code></pre><h4 id="2-多列索引"><a href="#2-多列索引" class="headerlink" title="2.多列索引"></a>2.多列索引</h4><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把<code>actor_id</code>和<code>film_id</code>设置为多列索引。</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> film_id, actor_ <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> sakila.film_actor<span class="hljs-keyword">WHERE</span> actor_id = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> film_id = <span class="hljs-number">1</span>;</code></pre><h4 id="3-索引列的顺序"><a href="#3-索引列的顺序" class="headerlink" title="3.索引列的顺序"></a>3.索引列的顺序</h4><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为1，此时每个记录都有唯一肚饿索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中<code>customer_id</code>的选择性比<code>staff_id</code>更高，因此最好把 customer_id 列放在多列索引的前面：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> staff_id)/<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> staff_id_selectivity,<span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> customer_id)/<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> customer_id_selectivity,<span class="hljs-keyword">COUNT</span>(*)<span class="hljs-keyword">FROM</span> payment;</code></pre><pre><code class="hljs text">   staff_id_selectivity: 0.0001customer_id_selectivity: 0.0373               COUNT(*): 16049</code></pre><h4 id="4-前缀索引"><a href="#4-前缀索引" class="headerlink" title="4.前缀索引"></a>4.前缀索引</h4><p>对于 BLOB 、 TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>前缀长度的选择需要根据索引选择性来确定。</p><h4 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5.覆盖索引"></a>5.覆盖索引</h4><p>索引包含所有需要查询的字段的值，具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读索引能大大减少数据访问量；</li><li>一些存储引擎（例如MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只能访问索引可以不使用系统调用（通常比较费时）；</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则不需访问主索引。</li></ul><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+ Tree 索引是有序性的，可以使用<code>order by</code>和<code>group by</code>操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><h3 id="索引的使用条件"><a href="#索引的使用条件" class="headerlink" title="索引的使用条件"></a>索引的使用条件</h3><ul><li>对于非常小的表：大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表：索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如：<font color=#FF000>分区技术</font>。</li></ul><h2 id="二、查询性能优化"><a href="#二、查询性能优化" class="headerlink" title="二、查询性能优化"></a>二、查询性能优化</h2><h3 id="使用-Explain-进行分析"><a href="#使用-Explain-进行分析" class="headerlink" title="使用 Explain 进行分析"></a>使用 <font color=#FF000>Explain</font> 进行分析</h3><p>Explain 用来分析 select 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。比较重要的字段有：</p><ul><li><strong>select_type</strong>：查询类型，有简单查询、联合查询、子查询等；</li><li><strong>key</strong>：使用的索引；</li><li><strong>rows</strong>：扫描的行数</li></ul><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><h4 id="1-减少请求的数据量"><a href="#1-减少请求的数据量" class="headerlink" title="1.减少请求的数据量"></a>1.减少请求的数据量</h4><ul><li>只返回必要的列：最好不要使用<code>select *</code>语句；</li><li>只返回必要的行：使用<code>limit</code>语句来限制返回的数据；</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能的提升将会是非常明显的。</li></ul><h4 id="2-减少服务器扫描的行数"><a href="#2-减少服务器扫描的行数" class="headerlink" title="2.减少服务器扫描的行数"></a>2.减少服务器扫描的行数</h4><p>最有效的方式是使用索引来覆盖查询。</p><h3 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h3><h4 id="1-切分大查询"><a href="#1-切分大查询" class="headerlink" title="1.切分大查询"></a>1.切分大查询</h4><p>一个查询如果能一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询</p><h4 id="2-分解大连接查询"><a href="#2-分解大连接查询" class="headerlink" title="2.分解大连接查询"></a>2.分解大连接查询</h4><p>将一个大连接查询分解成每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p><ul><li>让缓存更高效</li><li>减少冗余记录的查询</li><li>减少锁竞争</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用<code>in()</code>代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效：<pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tag<span class="hljs-keyword">JOIN</span> tag_post <span class="hljs-keyword">ON</span> tag_post.tag_id=tag.id<span class="hljs-keyword">JOIN</span> post <span class="hljs-keyword">ON</span> tag_post.post_id=post.id<span class="hljs-keyword">WHERE</span> tag.tag=<span class="hljs-string">&#x27;mysql&#x27;</span>;</code></pre>优化：<pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tag <span class="hljs-keyword">WHERE</span> tag=<span class="hljs-string">&#x27;mysql&#x27;</span>;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tag_post <span class="hljs-keyword">WHERE</span> tag_id=<span class="hljs-number">1234</span>;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> post <span class="hljs-keyword">WHERE</span> post.id <span class="hljs-keyword">IN</span> (<span class="hljs-number">123</span>,<span class="hljs-number">456</span>,<span class="hljs-number">567</span>,<span class="hljs-number">9098</span>,<span class="hljs-number">8904</span>);</code></pre></li></ul><h2 id="三、存储引擎"><a href="#三、存储引擎" class="headerlink" title="三、存储引擎"></a>三、存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ol><li>是 <font color=#FF000>MySQL 默认</font>的事务型存储引擎，只有在需要它不支持的特性是，才考虑使用其它存储引擎；</li><li>实现了四个标准的隔离级别，默认级别是：可重复读(REPEATABLE READ)。可重复读隔离级别下，通过 <code>多版本并发控制(MVCC) + Next-Key Locking</code> 防止幻影读；</li><li>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升；</li><li>内部做了很多优化，包括：从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够快速插入操作的插入缓冲区等；</li><li>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取；</li><li><font color=#FF000>适用于：</font>应用中需要执行大量的 INSERT 或 UPDATE 操作</li></ol><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ol><li>设计简单，数据以紧密格式存储，使用场景：对于只读数据，或者表比较小、可以容忍修复操作；</li><li>提供了大量的特性，包括：压缩表、空间数据索引等，提供高速存储和检索，以及全文搜索能力；</li><li>不支持事务；</li><li>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以用往表中插入新的记录，这称为<code>并发插入(CONCURRENT INSERT)</code>；</li><li>可以手工或自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作会非常慢；</li><li>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引写入磁盘中，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机奔溃时会造成索引损坏，需要执行修改操作；</li><li><font color=#FF000>适用于：</font>应用中需要执行大量的 SELECT 查询</li></ol><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul><li><strong>事务</strong>：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句；</li><li><strong>并发</strong>：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁；</li><li><strong>外键</strong>：InnoDB 支持外键；</li><li><strong>备份</strong>：InnoDB 支持在线热备份；</li><li><strong>崩溃恢复</strong>：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复速度也更慢；</li><li><strong>其它特性</strong>：MyISAM支持压缩表和空间索引。</li></ul><h2 id="四、数据类型"><a href="#四、数据类型" class="headerlink" title="四、数据类型"></a>四、数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ul><li><code>TINYINT</code>, <code>SMALLINT</code>, <code>MEDIUMINT</code>, <code>INT</code>, <code>BIGINT</code> 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</li><li>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</li></ul><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul><li><code>FLOAT</code> 和 <code>DOUBLE</code> 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</li><li>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>主要有 <code>CHAR</code> 和 <code>VARCHAR</code> 两种类型，一种是定长的，一种是变长的。</li><li>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</li><li>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</li></ul><h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><p>MySQL 提供了两种相似的日期时间类型：<code>DATETIME</code> 和 <code>TIMESTAMP</code>。</p><h4 id="1-DATETIME"><a href="#1-DATETIME" class="headerlink" title="1.DATETIME"></a>1.DATETIME</h4><ul><li>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</li><li>它与时区无关。</li><li>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22<span>:</span>37<span>:</span>08”，这是 ANSI 标准定义的日期和时间表示方法。</li></ul><h4 id="2-TIMESTAMP"><a href="#2-TIMESTAMP" class="headerlink" title="2.TIMESTAMP"></a>2.TIMESTAMP</h4><ul><li>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</li><li>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</li><li>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</li><li>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</li><li><font color=#FF000>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高</font>。</li></ul><h2 id="五、切分"><a href="#五、切分" class="headerlink" title="五、切分"></a>五、切分</h2><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p><font color=#FF000>水平切分</font>又称为<code>Sharding</code>，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。<br><img src="/resource/img/java/MySQLSharding.jpg"></p><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p><font color=#FF000>垂直切分</font>是将一个表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如：将原本的电商数据库垂直切分为商品数据库、用户数据库等。<br><img src="/resource/img/java/MySQLvVertical.jpg"></p><h3 id="Sharding-水平切分-策略"><a href="#Sharding-水平切分-策略" class="headerlink" title="Sharding(水平切分)策略"></a>Sharding(水平切分)策略</h3><ul><li><strong>哈希取模</strong>：hash(key) % N；</li><li><strong>范围</strong>：可以是 ID 范围也可以是时间范围；</li><li><strong>映射表</strong>：使用单独的一个数据库来存储映射关系。</li></ul><h3 id="Sharding存在的问题"><a href="#Sharding存在的问题" class="headerlink" title="Sharding存在的问题"></a>Sharding存在的问题</h3><h4 id="1-事务问题"><a href="#1-事务问题" class="headerlink" title="1.事务问题"></a>1.事务问题</h4><p><font color=#FF000>解决办法</font>：使用分布式事务解决，比如 XA 接口。</p><h4 id="2-连接"><a href="#2-连接" class="headerlink" title="2.连接"></a>2.连接</h4><p><font color=#FF000>解决办法</font>：可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。 </p><h4 id="3-ID-唯一性"><a href="#3-ID-唯一性" class="headerlink" title="3.ID 唯一性"></a>3.ID 唯一性</h4><p><font color=#FF000>解决办法</font>：</p><ul><li>使用全局唯一 ID（GUID）；</li><li>为每个分片(Sharding)指定一个 ID 范围；</li><li>分布式 ID 生成器（如 Twitter 的 <a href="https://blog.csdn.net/fly910905/article/details/82054196">Snowflake</a> 算法）</li></ul><h2 id="六、数据复制"><a href="#六、数据复制" class="headerlink" title="六、数据复制"></a>六、数据复制</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主要涉及三个线程：binlog 线程、 I/O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong>：负责将主服务器上的数据更改写入二进制日志（Binary log）中；</li><li><strong>I/O 线程</strong>：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）中；</li><li><strong>SQL 线程</strong>：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。<br><img src="/resource/img/java/MasterSlave.png"><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><font color=#FF000>概念</font>：主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。<br>读写分离能提高性能的主要原因在于：</li><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用<code>代理方式</code>来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。<br><img src="/resource/img/java/MySQLProxy.png"></p><h2 id="谈谈select语句执行过程？"><a href="#谈谈select语句执行过程？" class="headerlink" title="谈谈select语句执行过程？"></a>谈谈select语句执行过程？</h2><p>MySQL 查询的大致语法结构如下：</p><pre><code class="hljs sql">(5)<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> &lt;select_list&gt;                     (<span class="hljs-number">1</span>)<span class="hljs-keyword">FROM</span> &lt;left_table&gt; &lt;join_type&gt; <span class="hljs-keyword">JOIN</span> &lt;right_table&gt; <span class="hljs-keyword">ON</span> &lt;on_predicate&gt;(<span class="hljs-number">2</span>)<span class="hljs-keyword">WHERE</span> &lt;where_predicate&gt;(<span class="hljs-number">3</span>)<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> &lt;group_by_specification&gt;(<span class="hljs-number">4</span>)<span class="hljs-keyword">HAVING</span> &lt;having_predicate&gt;(<span class="hljs-number">6</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> &lt;order_by_list&gt;(<span class="hljs-number">7</span>)<span class="hljs-keyword">LIMIT</span> n, m</code></pre><p>查询处理的顺序如下：</p><ol><li><strong>from</strong></li><li><strong>on</strong></li><li><strong>join</strong></li><li><strong>where</strong></li><li><strong>group by</strong>：对结果集进行分组，如统计用户可以访问多少个菜单(<code>select role_id, count(menu_id) from sys_role_menu group by role_id;</code>)</li><li><strong>having</strong>：having 子句用于筛选查询结果，如查询总成绩&gt;1000的学生，我们不能用where来筛选超过1000的学生，因为表中不存在这样一条记录<code>having sun(nums) &gt; 1000</code></li><li><strong>select</strong></li><li><strong>distinct</strong>：去重</li><li><strong>order by</strong>：对结果集进行排序</li><li><strong>limit</strong></li></ol><p>这些步骤执行时，每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只是最后一步生成的表才会返回给调用者。如果没有在查询中指定某一子句，将跳过相应的步骤。</p><h2 id="为什么使用数据索引能提高效率？"><a href="#为什么使用数据索引能提高效率？" class="headerlink" title="为什么使用数据索引能提高效率？"></a>为什么使用数据索引能提高效率？</h2><ol><li>数据索引的存储是有序的；</li><li>在有序情况下，通过索引查询一个数据是无需遍历索引记录的；</li><li>极端情况下，数据索引的查询效率为二分发查询效率，趋近于log<sub>2</sub>N</li></ol><h2 id="什么情况下应不建或少建索引？"><a href="#什么情况下应不建或少建索引？" class="headerlink" title="什么情况下应不建或少建索引？"></a>什么情况下应不建或少建索引？</h2><ol><li>表记录太少；</li><li>经常插入、修改、删除的表；</li><li>数据重复且分布均匀的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度；</li><li>经常和主字段一块查询但主字段索引值比较多的表字段。</li></ol><h2 id="谈谈-MVCC？"><a href="#谈谈-MVCC？" class="headerlink" title="谈谈 MVCC？"></a>谈谈 MVCC？</h2><p>首先我们要了解LBCC（Lock-Based Concurrency Control）——基于锁的并发控制，而MVCC (Multi-Version Concurrency Control)并发版本控制 是在 LBCC 上的改进，主要是在读操作上提高了并发量。</p><p>InnoDB存储引擎，实现的是MVCC<br><strong>MVCC最大的好处</strong>：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。</p><h2 id="快照读、当前读和-MVCC"><a href="#快照读、当前读和-MVCC" class="headerlink" title="快照读、当前读和 MVCC"></a>快照读、当前读和 MVCC</h2><h3 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1.快照读"></a>1.快照读</h3><p><strong>快照读</strong>是基于 MVCC 和 undo log 来实现的，适用于简单 select 语句。</p><ul><li><strong>读已提交</strong>：一个事务内操作一条数据，可以查询到另一个已提交事务操作同一条数据的最新值。（<code>Oracle 默认隔离级别</code>）所以当一个事务内有多个 sql 查询时，会生成多个 readView，每条 sql 都能查询到最新 readView 的值；</li><li><strong>可重复读</strong>：每个事务只关注自己事务开始查询到的数据值，无论事务查询同一条数据多少次，该数据改了多少次，都只能查询到事务开始之前的数据值。（<code>MySQL 默认隔离级别</code>）所以当一个事务内有多个 sql 查询时，读取到的 readView 都是同一个，那么查询某条数据的值也是一样的。</li></ul><p>而所谓 <strong>MVCC 并发版本控制</strong>，是靠 readView（事务视图）来实现的，readView 是针对同一条数据生成的视图。多个 readView 组成 undo log（回滚日志）。</p><h3 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2.当前读"></a>2.当前读</h3><p><strong>当前读</strong>是基于 <em>临键锁（行锁 + 间歇锁）</em> 来实现的，适用于insert、update、delete、select … for update、select … lock in share mode语句，以及加锁了的 select 语句。</p><p>更新数据时，都是先读后写，而这个读，就是当前读；读取数据时，读取该条数据的已经提交的最新事务生成的 readView。假设现在事务A有2个 sql 语句，事务开始时生成 readView(id = n)：</p><ul><li>如果第一个 sql 操作一条数据时读当前的 readView(id = n)，此时开始一个事务B生成 readView(id = n+1)，并且对该条数据做了操作(非简单select操作)，此时事务A的第二个 sql 语句<strong>当前读</strong>该数据，就会读取到最新的 readView(id = n+1)；</li><li>假设事务A的第二个 sql 语句操作数据时，事务B还未提交其非简单的 select 操作，那么这条数据就会被事务B<strong>写锁</strong>锁住，所以事务A就会阻塞，等待事务B释放锁。</li></ul><h2 id="char、varchar、text的区别"><a href="#char、varchar、text的区别" class="headerlink" title="char、varchar、text的区别"></a>char、varchar、text的区别</h2><ol><li>char 长度固定，每条数据占用等长字节空间；适合用在身份证号码、手机号码等；</li><li>varchar 可变长度，可以设置最大长度；适合用在长度可变的属性；</li><li>text 不设置长度，当不知道属性的最大长度时，适用text；</li></ol><p>查询速度：char最快 &rarr; varchar其次 &rarr; text最慢</p><ul><li>*<em>char(n)**：中的 n 表示字符数，最大字符数是255；如果是 utf8 编码，那么 char 类型占255</em>3个字节（utf8 下一个字符占用1~3个字节）</li><li>**varchar(n)**：中的 n 表示字符数，最大空间是65535个字节，存放字符数量跟字符集有关系；(实际范围是65532或65533， 因为内容头部会占用1或2个字节保存该字符串的长度；如果字段default null，整条记录还需要1个字节保存默认值 null)<ul><li>MySQL5.0.3 以前版本：n表示字节数；</li><li>MySQL5.0.3 之后版本：n表示字符数；</li></ul></li><li><strong>text</strong>：跟varchar基本相同， 理论上最多保存65535个字符， 实际上text占用内存空间最大也是65535个字节； 考虑到字符编码方式， 一个字符占用多个字节， text并不能存放那么多字符； 跟varchar的区别是text需要2个字节空间记录字段的总字节数</li><li>注意：由于 varchar 查询速度更快，所以能用 varchar 的时候就不要用 text！</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java面试题</tag>
      
      <tag>基础知识</tag>
      
      <tag>数据库基础</tag>
      
      <tag>MySQL</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架面试总结</title>
    <link href="/2020/11/18/java/Spring/"/>
    <url>/2020/11/18/java/Spring/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring是什么？"><a href="#Spring是什么？" class="headerlink" title="Spring是什么？"></a>Spring是什么？</h2><p><font color=#FF000>Spring</font>是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：<strong>基于XML的配置</strong>、<strong>基于注解的配置</strong>、<strong>基于Java的配置</strong>。<br>主要由以下几个模块组成：</p><ul><li><strong>Spring Core</strong>：核心类库，提供IoC服务；</li><li><strong>Spring Context</strong>：提供框架式的Bean访问方式，以及企业级功能（<a href="https://baike.baidu.com/item/JNDI">JNDI</a>、定时任务等）；</li><li><strong>Spring AOP</strong>：AOP服务；</li><li><strong>Spring DAO</strong>：对JDBC的抽象，简化了数据访问异常的处理；</li><li><strong>Spring ORM</strong>：对现有的ORM框架的支持；</li><li><strong>Spring Web</strong>：提供了基本的面向Web的综合特性，例如多文件上传；</li><li><strong>Spring MVC</strong>：提供面向Web应用的Model-View-Controller实现；</li></ul><h2 id="Spring的优点是什么？"><a href="#Spring的优点是什么？" class="headerlink" title="Spring的优点是什么？"></a>Spring的优点是什么？</h2><ol><li>Spring属于低侵入式设计，代码的污染极低；</li><li>Spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；</li><li>Spring提供了AOP技术，支持将一些通用的任务，如：安全、事务、日志、权限等进行集中式管理，从而提供更好的复用；</li><li>Spring对主流的应用框架提供了集成支持。</li></ol><h2 id="Spring的AOP理解"><a href="#Spring的AOP理解" class="headerlink" title="Spring的AOP理解"></a>Spring的AOP理解</h2><p>&nbsp;&nbsp;OOP面向对象。允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的应用。<br>&nbsp;&nbsp;<strong>AOP</strong>，一般称为面向切面，作为面向对象的一种补充，<font color=#FF000>用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块</font>，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。<br>&nbsp;&nbsp;<strong>AOP实现的关键</strong>在于代理模式，AOP代理主要分为<strong>静态代理</strong>和<strong>动态代理</strong> 。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。<br>(1) <strong>AspectJ是静态代理的增强</strong>，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，它会在编译阶段将AspectJ（切面）织入到Java字节码中，运行的时候就是增强之后的AOP对象。<br>(2) <strong>Spring AOP使用的是动态代理</strong>，所谓动态代理，就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p><strong><code>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理</code></strong> ：</p><ol><li>JDK动态代理只提供接口的代理，不支持类的代理，核心是InvocationHandler接口和Proxy类，InvocationHandler通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着Proxy类利用InvocationHandler接口动态创建一个符合某一接口的实例，生成目标类的代理对象。<blockquote><p>InvocationHandler的invoke(Object  proxy,Method  method,Object[] args)方法参数解析：</p><blockquote><p>proxy：是最终生成的代理实例；<br>method：是被代理目标实例的某个具体方法；<br>args：是被代理目标实例某个方法的具体入参，在方法反射调用时使用。</p></blockquote></blockquote></li><li>如果代理类没有实现InvocationHandler接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Core Generation Library）是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li><li><strong>静态代理与动态代理的区别</strong>在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</li></ol><h2 id="Spring的IoC理解"><a href="#Spring的IoC理解" class="headerlink" title="Spring的IoC理解"></a>Spring的IoC理解</h2><ol><li><code>IoC就是控制反转</code>，是指创建对象的控制权的转移，以前创建对象的主动权时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。<code>DI依赖注入</code>，和控制反转是同一个概念的不同角度的描述，即：应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。</li><li>最直观的表达就是，IoC让对象的创建不用去 new 了，可以由Spring自动生产，使用Java的反射机制，根据配置文件在程序运行时动态的去创建对象以及管理对象，并调用对象的方法。</li><li>Spring的IoC有三种注入方式：构造器注入、setter方法注入、根据注解注入。</li></ol><blockquote><p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p></blockquote><h2 id="BeanFactory和ApplicationContext的区别？"><a href="#BeanFactory和ApplicationContext的区别？" class="headerlink" title="BeanFactory和ApplicationContext的区别？"></a>BeanFactory和ApplicationContext的区别？</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p><ol><li><strong>BeanFactory</strong>：是Spring里面最底层的接口，包含了各种Bean的定义，读取Bean配置文档，管理Bean的加载、实例化，控制Bean的生命周期，维护Bean之间的依赖关系。<strong>ApplicationContext</strong>作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的架构功能：<br>&nbsp;&nbsp;&nbsp;&nbsp;① 继承MessageSource，因此支持国际化；<br>&nbsp;&nbsp;&nbsp;&nbsp;② 统一的资源文件访问方式；<br>&nbsp;&nbsp;&nbsp;&nbsp;③ 提供在监听器中注册Bean的事件；<br>&nbsp;&nbsp;&nbsp;&nbsp;④ 同时加载多个配置文件；<br>&nbsp;&nbsp;&nbsp;&nbsp;⑤ 载入多个（有继承关系）上下文，使用每一个上下文对象都专注于一个特定的层次，比如应用的web层。</li><li><font color=#0000FF>BeanFactory采用的是延迟加载的形式来注入Bean的，即只有在使用到某个Bean时（调用getBean()），才对该Bean进行加载实例化。</font>弊端是：不能及时发现一些存在的Spring配置问题，如果Bean的某一个属性没有注入，BeanFactory加载后直到第一次调用getBean方法才会抛出异常。<br><font color=#0000FF>ApplicationContext是在容器启动时，一次性创建了所有的Bean</font>，可以及时发现Spring配置中存在的错误，利于检查所依赖属性是否注入。ApplicationContext启动后预载入所有单例的Bean，通过预载入单例Bean确保需要时无需等待，因为它们已经创建好了。<br>相对于基本的BeanFactory，<font color=#0000FF>ApplicationContext唯一不足是占用内存空间</font>，当应用程序配置的Bean较多时程序启动较慢。</li><li>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如：使用ContextLoader；</li><li>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的<strong>区别</strong>是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</li></ol><h2 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h2><p>首先说一下Servlet的生命周期：实例化 &rarr; 初始init &rarr; 接收请求service &rarr; 销毁destroy；<br>Spring上下文中的Bean生命周期也类似：<br><font color=#0000FF><strong>（1）实例化Bean：</strong></font><br>对于BeanFactory容器，当客户向容器请求一个尚未初始化的Bean时，或初始化Bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的Bean。</p><p><font color=#0000FF><strong>（2）设置对象属性（依赖注入）：</strong></font><br>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息以及通过BeanWrapper提供的设置属性的接口完成依赖注入。</p><p><font color=#0000FF><strong>（3）处理Aware接口：</strong></font><br>接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：<br>① 如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；<br>② 如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的事Spring工厂本身；<br>③ 如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext context)方法，传入Spring上下文对象</p><p><font color=#0000FF><strong>（4）BeanPostProcessor：</strong></font><br>如果想对Bean进行一些自定义的处理，那么可以让Bean实现BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p><p><font color=#0000FF><strong>（5）InitializingBean 与init-method：</strong></font><br>如果Bean在Spring配置文件中配置了init-method属性，则会自动调用其配置的初始化方法。</p><p><font color=#0000FF><strong>（6）如果这个Bean走了第四步：</strong></font><br>如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束之后调用的，所以可应用于内存或缓存技术；</p><p><code>以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。</code>&uarr;&uarr;&uarr;</p><p><font color=#0000FF><strong>（7）DisposableBean(清理)：</strong></font><br>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p><p><font color=#0000FF><strong>（8）destroy-method：</strong></font><br>最后，如果这个Bean的Spring配置中配置了destroy-method属性，就会自动调用其配置的销毁方法。</p><h2 id="Spring-Bean-Scope-作用域"><a href="#Spring-Bean-Scope-作用域" class="headerlink" title="Spring Bean Scope(作用域)"></a>Spring Bean Scope(作用域)</h2><p>Spring容器中的Bean可以分为5个范围：</p><ol><li><strong>singleton</strong>：<font color=#FF000>默认</font>，每个容器中只有一个Bean的实例，单例模式由BeanFactory自身维护；</li><li><strong>prototype</strong>：为每一个Bean请求提供一个实例；</li><li><strong>request</strong>：为每一个网络请求创建一个实例，在请求完成后，Bean会失效并被垃圾回收器回收；</li><li><strong>session</strong>：与request范围类似，确保每个session中有一个Bean实例，在session过期后，Bean会随之失效；</li><li><strong>global-session</strong>：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很对portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这个全局变量需要存储在global-session中。全局作用域与Servlet的session作用域效果相同。</li></ol><h2 id="Spring框架中的单例Beans是线程安全的吗？"><a href="#Spring框架中的单例Beans是线程安全的吗？" class="headerlink" title="Spring框架中的单例Beans是线程安全的吗？"></a>Spring框架中的单例Beans是线程安全的吗？</h2><p>Spring框架并没有对单例Bean进行任何多线程的封装处理。关于单例Bean的线程安全和并发问题需要开发者自行去搞定，但实际上大部分的Spring Bean并没有可变的状态（比如Serview类和DAO类），所以在某种程度上说Spring的单例Bean是线程安全的。如果Bean有多种状态的话（比如View Model对象），就需要自行保证线程安全。最浅显的<strong>解决办法</strong>就是将多态Bean的作用域由“<strong>singleton</strong>”变更为“<strong>prototype</strong>”。</p><h2 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h2><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用<font color=#0000FF>ThreadLocal进行处理，解决线程安全问题</font>；<br>ThreadLocal和线程同步机制都是为了解决多线程中相同变量访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“时间换空间”的方式。<br>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本（JMM内存模型），从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><h2 id="Spring注入Bean的几种方式"><a href="#Spring注入Bean的几种方式" class="headerlink" title="Spring注入Bean的几种方式"></a>Spring注入Bean的几种方式</h2><ol><li>set方法注入；</li><li>构造器注入：①通过index设置参数位置；②通过type设置参数类型；</li><li>静态工厂注入；</li><li>实例工厂；</li></ol><h2 id="Spring的自动装配"><a href="#Spring的自动装配" class="headerlink" title="Spring的自动装配"></a>Spring的自动装配</h2><p>在Spring中，对象无需自己查找或创建与其关联的其它对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用Autowire来自动装载模式。<br>在Spring框架xml配置中共有5中自动装配：</p><ol><li><strong>no</strong>：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配Bean；</li><li><strong>byName</strong>：通过Bean的名称进行自动装配，如果一个Bean的property与另一个Bean的name相同，就进行自动装配；</li><li><strong>byType</strong>：通过参数的数据类型进行自动装配；</li><li><strong>constructor</strong>：利用构造函数进行装配，并且构造函数的参数通过byType进行装配；</li><li><strong>autodetect</strong>：自动探测，如果有构造方法，则通过constructor方式进行自动装配，否则使用byType方式；</li></ol><p>基于注解的方式：<br>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><ul><li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li><li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li><li>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</li></ul><h2 id="Spring中用到了哪些设计模式？"><a href="#Spring中用到了哪些设计模式？" class="headerlink" title="Spring中用到了哪些设计模式？"></a>Spring中用到了哪些设计模式？</h2><ol><li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</li><li>单例模式：Bean默认为单例模式；</li><li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li><li>模板模式：用来解决代码重复的问题，比如：RestTemplate、JmsTemplate、JpaTemplate；</li><li>观察者模式：定义对象见一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象就会得到通知被制动更新，如Spring中listener的实现——ApplicationListener。</li></ol><h2 id="Component和-Bean的区别是什么？"><a href="#Component和-Bean的区别是什么？" class="headerlink" title="@Component和@Bean的区别是什么？"></a>@Component和@Bean的区别是什么？</h2><ol><li><code>作用对象不同</code>：@Component注解作用于类，而@Bean注解作用于方法；</li><li><code>@Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中(我们可以使用@ComponentScan注解定义要扫描的路径</code>。@Bean注解通常是我们在标有该注解的方法中定义产生这个Bean，@Bean告诉Spring这个是某个类的实例，当需要时还给我；</li><li><code>@Bean注解比@Component注解的自定义性更强</code>，而且很多地方我们只能通过@Bean注解来注册Bean，比如当我们引用第三方库中的类需要装配到Spring容器时，只能通过@Bean来实现。</li></ol><p>@Bean注解使用实例：</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl();    &#125;&#125;</code></pre><p>上面的代码相当于下面的xml配置：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transferService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.soldier.TransferServiceImpl&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><p>下面这个例子无法通过@Component实现：</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> OneService <span class="hljs-title">getService</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status)</span> </span>&#123;    <span class="hljs-keyword">case</span> (status)  &#123;        when <span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> serviceImpl1();        when <span class="hljs-number">2</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> serviceImpl2();    &#125;&#125;</code></pre><h2 id="类声明为Spring的Bean的注解有哪些？"><a href="#类声明为Spring的Bean的注解有哪些？" class="headerlink" title="类声明为Spring的Bean的注解有哪些？"></a>类声明为Spring的Bean的注解有哪些？</h2><ul><li><strong>@Component</strong>：通用的注解，可标注任意类为 Spring 组件。</li><li><strong>@Repository</strong>：对应DAO层，主要同于数据库相关操作；</li><li><strong>@Service</strong>：对应服务层，主要涉及一些复杂的逻辑，需要用到DAO层；</li><li><strong>@Controller</strong>：对应Spring MVC控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h2 id="Spring管理事务的方式有几种？"><a href="#Spring管理事务的方式有几种？" class="headerlink" title="Spring管理事务的方式有几种？"></a>Spring管理事务的方式有几种？</h2><ol><li><strong>编程式事务</strong>，在代码中硬编程，<code>不推荐</code>；</li><li><strong>声明式事务</strong>，在配置文件中配置，<code>推荐</code>，共分为两种：<ol><li>基于XML的声明式事务；</li><li>基于注解的声明式事务。</li></ol></li></ol><h2 id="Spring的事务传播行为"><a href="#Spring的事务传播行为" class="headerlink" title="Spring的事务传播行为"></a>Spring的事务传播行为</h2><ol><li><strong>PROPAGATION_REQUIRED</strong>：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</li><li><strong>PROPAGATION_SUPPORTS</strong>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。‘</li><li><strong>PROPAGATION_MANDATORY</strong>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li><li><strong>PROPAGATION_REQUIRES_NEW</strong>：创建新事务，无论当前存不存在事务，都创建新事务。</li><li><strong>PROPAGATION_NOT_SUPPORTED</strong>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li><strong>PROPAGATION_NEVER</strong>：以非事务方式执行，如果当前存在事务，则抛出异常。</li><li><strong>PROPAGATION_NESTED</strong>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</li></ol><h2 id="Spring事务中的隔离级别有哪几种"><a href="#Spring事务中的隔离级别有哪几种" class="headerlink" title="Spring事务中的隔离级别有哪几种?"></a>Spring事务中的隔离级别有哪几种?</h2><ol><li><strong>ISOLATION_DEFAULT</strong>：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。</li><li><strong>ISOLATION_READ_UNCOMMITTED</strong>：读未提交，允许另外一个事务可以看到这个事务未提交的数据。</li><li><strong>ISOLATION_READ_COMMITTED</strong>：读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新。</li><li><strong>ISOLATION_REPEATABLE_READ</strong>：可重复读，保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新。</li><li><strong>ISOLATION_SERIALIZABLE</strong>：一个事务在执行的过程中完全看不到其他事务对数据库所做的更新。</li></ol><h2 id="SpringMVC的工作原理了解嘛？"><a href="#SpringMVC的工作原理了解嘛？" class="headerlink" title="SpringMVC的工作原理了解嘛？"></a>SpringMVC的工作原理了解嘛？</h2><p><img src="/resource/img/java/SpringMVC.jpg"><br><font color=#FF000><strong>流程说明</strong>：</font></p><ol><li>客户端发送请求，直接请求到 DispatcherServlet；</li><li>DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler；</li><li>解析得到的这个Handler（也就是我们平时说的Controller）后，开始由 HandlerAdapter 适配器处理；</li><li>HandlerAdapter 会根据 Handler（Controller控制器） 来调用真正的处理器处理请求，并处理相应的业务逻辑。处理完成后会返回一个 ModelAndView 对象：Model是返回的数据对象、View是个逻辑上的View；</li><li>ViewResolver 会根据逻辑 View 查找实际的View；</li><li>DispatcherServlet 把返回的Model 传给 View 进行视图渲染；</li><li>最后把View 返回给客户端。</li></ol><h2 id="SpringMVC的常用注解"><a href="#SpringMVC的常用注解" class="headerlink" title="SpringMVC的常用注解"></a>SpringMVC的常用注解</h2><h3 id="1-组件型"><a href="#1-组件型" class="headerlink" title="1.组件型"></a>1.组件型</h3><p>作用于类上，将其声明为Spring的Bean，然后统一管理。</p><ul><li>@Component：通用的注解，可标注任意类为 Spring 组件。</li><li>@Repository：对应DAO层，主要同于数据库相关操作；</li><li>@Service：对应服务层，主要涉及一些复杂的逻辑，需要用到DAO层；</li><li>@Controller：对应Spring MVC控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h3 id="2-请求和参数型"><a href="#2-请求和参数型" class="headerlink" title="2.请求和参数型"></a>2.请求和参数型</h3><ol><li><code>@RequestMapping</code>：用于处理请求地址映射，可以作用于类和方法上<br> 1.1 value：定义request请求的映射地址<br> 1.1 method：定义地request址请求的方式，包括【GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE.】默认接受get请求，如果请求方式和定义的方式不一样则请求无法成功。<br> 1.1 params：定义request请求中必须包含的参数值。<br> 1.1 headers：定义request请求中必须包含某些指定的请求头，如：RequestMapping(value = “/something”, headers = “content-type=text/*”)说明请求中必须要包含”text/html”, “text/plain”这中类型的Content-type头，才是一个匹配的请求。<br> 1.1 consumes：定义请求提交内容的类型。<br> 1.1 produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/requestTest.do&quot;,params = &#123;&quot;name=sdf&quot;&#125;,headers = &#123;&quot;Accept-Encoding=gzip, deflate, br&quot;&#125;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndex</span><span class="hljs-params">()</span></span>&#123;    System.out.println(<span class="hljs-string">&quot;请求成功&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;&#125;</code></pre></li><li><code>@RequestParam</code>：用于获取传入参数的值<br> 2.1 value：参数的名称<br> 2.1 required：定义该传入参数是否必须，默认为true，（和@RequestMapping的params属性有点类似）<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/requestParams1.do&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">requestParams1</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(required = false)</span> String name)</span></span>&#123;    System.out.println(<span class="hljs-string">&quot;name = &quot;</span>+name);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;&#125;</code></pre></li><li><code>@PathVariable</code>：用于定义路径参数值<br> 3.1 value：参数的名称<br> 3.1 required：定义传入参数是否为必须值<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/&#123;myname&#125;/pathVariable2.do&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pathVariable2</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;myname&quot;)</span> String name)</span></span>&#123;    System.out.println(<span class="hljs-string">&quot;myname = &quot;</span>+name);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;&#125;</code></pre></li><li><code>@ResponseBody</code>：作用于方法上，可以将整个返回结果以某种格式返回，如json或xml格式<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/&#123;myname&#125;/pathVariable2.do&quot;)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pathVariable2</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;myname&quot;)</span> String name)</span></span>&#123;    System.out.println(<span class="hljs-string">&quot;myname = &quot;</span>+name);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;&#125;</code></pre></li><li><code>@ModelAttribute</code>：用于把参数保存到model中，可以注解方法或参数，注解在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session（前提时要有@SessionAttributes注解） 或模型属性中，@ModelAttribute(“attributeName”) 在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称。　<pre><code class="hljs java"><span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> UserEntity <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;    UserEntity userEntityr = <span class="hljs-keyword">new</span> UserEntity();    userEntityr.setUsername(<span class="hljs-string">&quot;asdf&quot;</span>);    <span class="hljs-keyword">return</span> userEntityr;&#125;<span class="hljs-meta">@RequestMapping(&quot;/modelTest.do&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsers</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span> UserEntity user)</span></span>&#123;    System.out.println(user.getUsername());    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index&quot;</span>;&#125;</code></pre></li><li><code>@SessionAttributes</code>：默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中。配合@ModelAttribute(“user”)使用的时候,会将对应的名称的model值存到session中<pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><span class="hljs-meta">@SessionAttributes(value = &#123;&quot;user&quot;,&quot;test1&quot;&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span></span>&#123;    <span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserEntity <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;        UserEntity userEntityr = <span class="hljs-keyword">new</span> UserEntity();        userEntityr.setUsername(<span class="hljs-string">&quot;asdf&quot;</span>);        <span class="hljs-keyword">return</span> userEntityr;    &#125;    <span class="hljs-meta">@RequestMapping(&quot;/modelTest.do&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsers</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span> UserEntity user ,HttpSession session)</span></span>&#123;        System.out.println(user.getUsername());        System.out.println(session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>));        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index&quot;</span>;    &#125;&#125;</code></pre></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Java面试题</tag>
      
      <tag>Spring， 框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP学习笔记</title>
    <link href="/2020/11/17/java/HTTP/"/>
    <url>/2020/11/17/java/HTTP/</url>
    
    <content type="html"><![CDATA[<h2 id="一、HTTP方法"><a href="#一、HTTP方法" class="headerlink" title="一、HTTP方法"></a>一、HTTP方法</h2><p>客户端发送的<strong>请求报文</strong>第一行为请求行，包含了方法字段。如<strong>GET请求</strong>：</p><pre><code class="hljs html">GET http://www.example.com/ HTTP/1.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cache-Control: max-age=0Host: www.example.comIf-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMTIf-None-Match: &quot;3147526947+gzip&quot;Proxy-Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 xxxparam1=1&amp;param2=2</code></pre><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><blockquote><p>获取资源</p></blockquote><p>现在大多数网络请求中，绝大部分使用的是GET方法。</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><blockquote><p>获取报文首部</p></blockquote><p>与GET方法类型，但不会返回报文主体部分。主要用于确认URL的有效性以及资源更新的日期时间等。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><blockquote><p>传输实体主体</p></blockquote><p>POST主要同于传输数据，而GET主要用来回去资源。</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a><del>PUT</del></h3><blockquote><p>上传文件</p></blockquote><p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><h3 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h3><blockquote><p>对资源进行部分修改</p></blockquote><p>PUT也可以用于修改资源，但是只能完全替换原始资源；PATCH允许部分修改。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><blockquote><p>删除文件</p></blockquote><p>与PUT功能相反，并且同样不带验证机制。</p><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><blockquote><p>查询支持的方法</p></blockquote><p>查询指定的URL能够支持的方法。会返回 <code>Allow：GET，POST，HEAD，OPTIONS</code> 这样的内容。</p><h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><blockquote><p>要求在与代理服务器通信是建立隧道</p></blockquote><p>使用<a href="https://baike.baidu.com/item/ssl">SSL</a>和<a href="https://baike.baidu.com/item/TLS">TLS</a>协议把通信内容加密后经网络隧道传输。</p><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a><del>TRACE</del></h3><blockquote><p>追踪路径</p></blockquote><p>服务器会将通信路径返回给客户端。通常不会使用 TRACE，并且它容易受到 <a href="https://zhuanlan.zhihu.com/p/61990354">XST 攻击（Cross-Site Tracing，跨站追踪）</a>。</p><h2 id="二、HTTP状态码"><a href="#二、HTTP状态码" class="headerlink" title="二、HTTP状态码"></a>二、HTTP状态码</h2><p>服务器返回的<strong>响应报文</strong>中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th align="center">状态码</th><th align="center">类别</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">Informational（信息性状态码）</td><td align="center">接收的请求正在处理</td></tr><tr><td align="center">2XX</td><td align="center">Success（成功状态码）</td><td align="center">请求正常处理完毕</td></tr><tr><td align="center">3XX</td><td align="center">Redirection（重定向状态码）</td><td align="center">需要进行附加操作以完成请求</td></tr><tr><td align="center">4XX</td><td align="center">Client Error（客户端错误状态码）</td><td align="center">客户端无法处理请求</td></tr><tr><td align="center">5XX</td><td align="center">Server Error（服务器错误状态码）</td><td align="center">服务器处理请求出错</td></tr></tbody></table><h3 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h3><ul><li><strong>100 Continue</strong>：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul><li><strong>200 OK</strong></li><li><strong>204 No Content</strong>：请求已经成功处理，但是返回的响应保卫不包含实体的主体部分。一般只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li><strong>206 Partial Content</strong>：表示客户端进行了范围请求，响应报文包含有Content-Range指定范围的实体内容。</li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul><li><strong>301 Moved Permanently</strong>：永久性重定向</li><li><strong>302 Found</strong>：临时性重定向</li><li><strong>303 See Other</strong>：和302有着相同的功能，但是303明确要求客户端应该采用GET方法获取资源。</li><li><strong>304 Not Modified</strong>：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回304状态码。</li><li><strong>307 Temporary Redirect</strong>：临时重定向，与302的含义类似，但是307要求浏览器不会把重定向请求的POST方法改为GET方法。</li></ul><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul><li><strong>400 Bad Request</strong>：请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong>：该状态码表示发送的请求需要有认证信息（BASIC认证、DIGEST认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden</strong>：请求被拒绝。</li><li><strong>404 Not Found</strong>：找不到页面。</li></ul><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><ul><li><strong>500 Internal Server Error</strong>：服务器正在执行请求时发生错误。</li><li><strong>503 Service Unavailable</strong>：服务器暂时处于超负载或正在停机维护，现在无法处理请求。</li></ul><h2 id="三、HTTPS"><a href="#三、HTTPS" class="headerlink" title="三、HTTPS"></a>三、HTTPS</h2><p>HTTP有以下安全性问题：</p><ol><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ol><p><font color=#FF000>HTTPS并不是新协议</font>，而是让HTTP先和SSL通信，再由SSL和TCP通信，也就是说HTTPS使用了隧道进行通信。<br>通过使用SSL，HTTPS具备了以下<strong>特点</strong>：</p><ul><li>加密（防窃听）</li><li>认证（防伪装）</li><li>完整性保护（防篡改）</li></ul><h3 id="HTTPS的加密算法"><a href="#HTTPS的加密算法" class="headerlink" title="HTTPS的加密算法"></a>HTTPS的加密算法</h3><h4 id="1-对称加密"><a href="#1-对称加密" class="headerlink" title="1.对称加密"></a>1.对称加密</h4><p>加密和解密使用同一密钥。</p><ul><li><strong>优点</strong>：运算速度快；</li><li><strong>缺点</strong>：无法安全地将密钥传输给通信方。<br><img src="/resource/img/java/SymmetricEncryption.png"></li></ul><h4 id="2-非对称加密"><a href="#2-非对称加密" class="headerlink" title="2.非对称加密"></a>2.非对称加密</h4><p>又称为公开密钥加密，加密和解密使用不同的密钥。<br>公开密钥所有人都可以获取，通信发送方获得接收方的公开密钥后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私钥解密。</p><ul><li><strong>优点</strong>：可以更安全地将公开密钥传输给通信发送方；</li><li><strong>缺点</strong>：运算速度慢。<br><img src="/resource/img/java/PublicKeyEncryption.png"></li></ul><h4 id="3-HTTPS采用的加密方式"><a href="#3-HTTPS采用的加密方式" class="headerlink" title="3.HTTPS采用的加密方式"></a>3.HTTPS采用的加密方式</h4><p>上面提到的<strong>对称加密</strong>方式的传输效率更高，但是无法安全地将密钥Secret Key传输给通信方。而<strong>非对称加密</strong>方式可以保证传输的安全性，因此我们可以利用非对称加密方式将Secret Key传输给通信方。HTTPS采用混合的加密机制，正是利用了上面提到的方案：</p><ul><li>使用<strong>非对称加密</strong>方式，传输<strong>对称加密</strong>方式所需要的Secret Key，从而保证安全性；</li><li>获取到Secret Key后，再使用<strong>对称加密</strong>方式进行通信，从而保证效率。</li></ul><h3 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h3><ul><li>因为需要进行加密解密等过程，所以速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h2 id="四、网络传输层协议"><a href="#四、网络传输层协议" class="headerlink" title="四、网络传输层协议"></a>四、网络传输层协议</h2><h3 id="UDP和TCP的特点"><a href="#UDP和TCP的特点" class="headerlink" title="UDP和TCP的特点"></a>UDP和TCP的特点</h3><ul><li><strong>用户数据报协议 UDP</strong>：是无连接的，尽最大可能交付，没有拥塞控制，<font color=#FF000>面向报文</font>，支持一对一、一对多、多对一、多对多的交互通信。<br><img src="/resource/img/java/UDP.jpg"></li><li><strong>传输控制协议 TCP</strong>：是面向连接的，提供可靠交付，有流量控制、拥塞控制，提供全双工通信，<font color=#FF000>面向字节流</font>，只能一对一。<br><img src="/resource/img/java/TCP.png"></li></ul><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>假设A为客户端，B为服务器端。</p><ul><li>首先B处于LISTEN（监听）状态，等待客户端的连接请求；</li><li>A想B发送连接请求报文：同步SYN=1、确认ACK=0、选择一个初始序号X；</li><li>B收到连接请求报文后，若同意，则向A发送连接确认报文：同步SYN=1、确认ACK=1、确认号为X+1、选择一个初始序号Y；</li><li>A收的B的连接确认后，还要向B发出确认：确认号为Y+1、序号为X+1；</li><li>B收到A的确认后，连接建立。</li></ul><h4 id="TCP三次握手的原因"><a href="#TCP三次握手的原因" class="headerlink" title="TCP三次握手的原因"></a>TCP三次握手的原因</h4><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论ACK，因为确认ACK在连接建立之后都为1。</p><ul><li>A发送连接释放报文：终止FIN=1；</li><li>B收到之后发出确认，此时TCP处于半关闭状态，B能向A发送数据但A不能向B发送数据；</li><li>当B不再需要连接时，发出连接释放报文：终止FIN=1；</li><li>A收到后发出确认，进入TIME-WAIT状态，等待2MSL（最大报文存活时间）后释放连接；</li><li>B收到A的确认后释放连接。</li></ul><h4 id="TCP四次挥手的原因"><a href="#TCP四次挥手的原因" class="headerlink" title="TCP四次挥手的原因"></a>TCP四次挥手的原因</h4><p>客户端发送了FIN连接释放报文后，服务器收到了这个报文，就进入了CLOSE-WAIT状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送FIN连接释放报文。</p><h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。<br>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送效率。将窗口字段设为0，则发送方不能发送数据。</p><h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞是，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。<br><font color=#FF000>TCP主要通过四个算法来进行拥塞控制</font>：慢开始、拥塞避免、快重传、快恢复。</p>]]></content>
    
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>计算机基础</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聊聊Map集合？</title>
    <link href="/2020/11/16/java/Map/"/>
    <url>/2020/11/16/java/Map/</url>
    
    <content type="html"><![CDATA[<h2 id="1-HashMap简介"><a href="#1-HashMap简介" class="headerlink" title="1.HashMap简介"></a>1.HashMap简介</h2><p>举一反三，HashMap与ArrayList、HashSet都是线程不安全的。<font color=#FF000>JDK1.7用的是头插法（先扩容再插入）</font>，而<font color=#FF000>JDK1.8及之后使用的都是尾插法（先插入再扩容）</font>。因为JDK1.7是用单链表进行的纵向延伸，当采用头插法就是能够提高插入的效率，但是也会容易出现<font color=#FF000><strong>逆序且环形链表死循环问题</strong></font>。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。<br><strong>JDK1.8及之后</strong>先插入，再判断是否有红黑树节点，再判断链表长度，当链表长度达到8是改为红黑树</p><h2 id="2-为什么HashMap要转红黑树？"><a href="#2-为什么HashMap要转红黑树？" class="headerlink" title="2.为什么HashMap要转红黑树？"></a>2.为什么HashMap要转红黑树？</h2><p>HashMap会触发链表转红黑树的两个条件是：</p><ol><li>链表的长度达到8个</li><li>数组的长度达到64个</li></ol><p>出现这种数据结构的转换，实际上就是：<font color=#FF000>空间和时间的权衡</font>。<br>（1）为了实现快速查找，HashMap 选择了数组而不是链表。以利用数组的索引实现 O(1) 复杂度的查找效率。<br>（2）为了利用索引查找，HashMap 引入 Hash 算法, 将 key 映射成数组下标: key -&gt; Index。<br>（3）引入 Hash 算法又导致了 Hash 冲突。为了解决 Hash 冲突，HashMap 采用链地址法，在冲突位置转为使用链表存储。<br>（4）链表存储过多的节点又导致了在链表上节点的查找性能的恶化。为了优化查找性能，HashMap 在链表长度超过 8 之后转而将链表转变成红黑树，以将 O(n) 复杂度的查找效率提升至 O(log n)。</p><h2 id="3-HashMap线程不安全案例"><a href="#3-HashMap线程不安全案例" class="headerlink" title="3.HashMap线程不安全案例"></a>3.HashMap线程不安全案例</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContainerNotSafeDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="hljs-number">0</span> ,<span class="hljs-number">8</span>));                System.out.println(map);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p>当线程数量大一点，比如30时，会出现并发修改异常<strong>java.util.ConcurrentModificationException</strong></p><h2 id="4-线程安全解决方案"><a href="#4-线程安全解决方案" class="headerlink" title="4.线程安全解决方案"></a>4.线程安全解决方案</h2><ol><li>Hashtable<pre><code class="hljs java">Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> Hashtable&lt;&gt;()</code></pre>Hashtable跟HashMap的关系与Vector跟ArrayList的关系一样，都是在所有操作方法中加入synchronized修饰，粒度大，不推荐使用！</li><li>使用JDK提供的Collections工具类<pre><code class="hljs java">Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="hljs-keyword">new</span> HashMap&lt;&gt;());</code></pre></li><li>JUC下的ConcurrentHashMap<pre><code class="hljs java">Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();</code></pre><font color=#FF000><strong>重点</strong></font>：ConcurrentHashMap使用分段锁Segment，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。<br>在计算map的size是是遍历所有Segment的size进行累加，先连续两次尝试不加锁的size是否一致，超过3次会给每个Segment加锁。（Segment分段锁继承自ReentrantLock重入锁）</li></ol><p><strong><em>JDK1.8抛弃Segment分段锁</em></strong>，利用CAS+Synchronized，数据结构采用：数组+链表+红黑树</p><h2 id="5-map遍历的几种方式？"><a href="#5-map遍历的几种方式？" class="headerlink" title="5.map遍历的几种方式？"></a>5.map遍历的几种方式？</h2><ol><li>keySet的for循环<pre><code class="hljs java"><span class="hljs-keyword">for</span>(String key : map.keySet())&#123;      System.out.println(key + <span class="hljs-string">&quot;--&quot;</span> + map.get(key));  &#125;</code></pre></li><li>keySet的iterator迭代器<pre><code class="hljs java">Iterator it=map.keySet().iterator();  <span class="hljs-keyword">while</span>(it.hasNext())&#123;      String key = it.next().toString();       String value = map.get(key);      System.out.println(key + <span class="hljs-string">&quot;--&quot;</span> + value);  &#125;</code></pre></li><li>entrySet的for循环<pre><code class="hljs java"><span class="hljs-keyword">for</span>(Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123;      System.out.println(entry.getKey() + <span class="hljs-string">&quot;--&quot;</span> + entry.getValue());  &#125;</code></pre></li><li>entrySet的iterator迭代器<pre><code class="hljs java">Set set = map.entrySet();       Iterator i = set.iterator();       <span class="hljs-keyword">while</span>(i.hasNext())&#123;        Map.Entry&lt;String, String&gt; entry = (Map.Entry&lt;String, String&gt;) i.next();      System.out.println(entry.getKey() + <span class="hljs-string">&quot;==&quot;</span> + entry.getValue());  &#125;</code></pre></li><li>java8还新增了forEach方式以及.stream().forEach</li></ol><p><strong>总结：</strong></p><ul><li>entrySet的方式整体都是比keySet方式要高一些；</li><li>单纯的获取key来说，两者的差别并不大，但是如果要获取value，还是entrySet的效率会更好，因为keySet需要从map中再次根据key获取value，而entrySet一次都全部获取出来；</li><li>iterator 迭代器方式比 foreach 的效率高。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Java面试题</tag>
      
      <tag>集合类不安全问题</tag>
      
      <tag>Map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聊聊Set集合？</title>
    <link href="/2020/11/16/java/Set/"/>
    <url>/2020/11/16/java/Set/</url>
    
    <content type="html"><![CDATA[<h2 id="1-HashSet简介"><a href="#1-HashSet简介" class="headerlink" title="1.HashSet简介"></a>1.HashSet简介</h2><p>HashSet与ArrayList类似，都是线程不安全的，但HashSet的底层是HashMap，调用add方法时只需要传一个参数作为key，value是公共的Object对象 PRESENT</p><h2 id="2-HashSet线程不安全案例"><a href="#2-HashSet线程不安全案例" class="headerlink" title="2.HashSet线程不安全案例"></a>2.HashSet线程不安全案例</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContainerNotSafeDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                set.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span> ,<span class="hljs-number">8</span>));                System.out.println(set);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p>当线程数量大一点，比如30时，会出现并发修改异常<strong>java.util.ConcurrentModificationException</strong></p><h2 id="3-线程安全解决方案"><a href="#3-线程安全解决方案" class="headerlink" title="3.线程安全解决方案"></a>3.线程安全解决方案</h2><ol><li>使用JDK提供的Collections工具类<pre><code class="hljs java">Set&lt;String&gt; set = Collections.synchronizedSet(<span class="hljs-keyword">new</span> HashSet&lt;&gt;());</code></pre></li><li>JUC下的CopyOnWriteArraySet<pre><code class="hljs java">Set&lt;String&gt; set = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</code></pre><font color=#FF000><strong>注意</strong></font>：CopyOnWriteArraySet的底层是通过CopyOnWriteArrayList实现的。</li></ol><h2 id="4-set遍历的几种方式？"><a href="#4-set遍历的几种方式？" class="headerlink" title="4.set遍历的几种方式？"></a>4.set遍历的几种方式？</h2><ol><li>for循环<pre><code class="hljs java"><span class="hljs-keyword">for</span> (String str : set) &#123;      System.out.println(str);&#125;</code></pre></li><li>iterator迭代器<pre><code class="hljs java">Iterator&lt;String&gt; it = set.iterator();<span class="hljs-keyword">while</span> (it.hasNext()) &#123;  String str = it.next();  System.out.println(str);&#125;</code></pre></li><li>set.forEach（java8）<pre><code class="hljs java">set.forEach(item -&gt; &#123;    System.out.println(item);&#125;);</code></pre></li><li>set.stream().forEach（java8）<pre><code class="hljs java">set.stream().forEach(item -&gt; &#123;    System.out.println(item);&#125;);</code></pre></li></ol><p><strong>总结：</strong></p><ul><li>iterator 迭代器方式比 foreach 的效率高；</li><li>forEach 最耗时；</li><li>stream forEach 比较耗时和 for 循环差不多。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Java面试题</tag>
      
      <tag>集合类不安全问题</tag>
      
      <tag>Set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList是线程不安全，请编码写一个不安全的案例并给出解决方案。</title>
    <link href="/2020/11/16/java/ArrayList/"/>
    <url>/2020/11/16/java/ArrayList/</url>
    
    <content type="html"><![CDATA[<h2 id="1-ArrayList简介"><a href="#1-ArrayList简介" class="headerlink" title="1.ArrayList简介"></a>1.ArrayList简介</h2><p>ArrayList 是基于数组实现的，所以支持快速随机访问。数组的默认大小为 10。每次扩容1.5 倍，扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高。<br>Vector出现在JDK1.0是线程安全的，ArrayList出现在JDK1.2是线程不安全的，因为Vector的操作使用了synchronized，保证了数据一致性但并发性下降</p><h2 id="2-ArrayList线程不安全案例"><a href="#2-ArrayList线程不安全案例" class="headerlink" title="2.ArrayList线程不安全案例"></a>2.ArrayList线程不安全案例</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContainerNotSafeDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 构造一个初始容量为10的空数组</span><span class="hljs-comment">//        List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><span class="hljs-comment">//        list.forEach(System.out :: println);</span>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span> ,<span class="hljs-number">8</span>));                System.out.println(list);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p>当线程数量大一点，比如30时，会出现并发修改异常<strong>java.util.ConcurrentModificationException</strong></p><h2 id="3-导致原因"><a href="#3-导致原因" class="headerlink" title="3.导致原因"></a>3.导致原因</h2><p><strong><em>并发争抢</em></strong>：<br>假设老师上课要考勤，List就是老师的签到表，加锁的时候有老师在维持秩序，同学们只能一个个轮流签到，这个同学签到好了才能到下一个；如果签到过程没有老师在 没人管理秩序，也就是没加锁，假设张三同学正在签到，才写了个“张”字，这时李四同学很粗暴的把签到表抢过去签，张三同学的笔就会在纸上画出一道长长的线，<font color=#FF000>这道长长的线就是程序出现的并发修改异常java.util.ConcurrentModificationException</font></p><h2 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4.解决方案"></a>4.解决方案</h2><ol><li>方法一：使用更古老更重的Vector<pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> Vector&lt;&gt;();</code></pre></li><li>方法二：使用JDK提供的Collections工具类<pre><code class="hljs java">List&lt;String&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());</code></pre>区别于Collection接口，我们使用的容器类List、Set都是继承自Collection接口，Collections是一个class工具类，可以构造出线程安全的List、Set，包括Map</li></ol><h2 id="5-限制不可以使用Vector和Collections工具类的解决方案"><a href="#5-限制不可以使用Vector和Collections工具类的解决方案" class="headerlink" title="5.限制不可以使用Vector和Collections工具类的解决方案"></a>5.限制不可以使用Vector和Collections工具类的解决方案</h2><p><strong><em>使用JUC下的CopyOnWriteArrayList</em></strong>：<br>以add()方法为例，CopyOnWrite容器即即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将容器Object[]进行copy，复制出一个新的容器Object[] newElements，然后往新的容器Object[] newElements里添加元素，添加完之后再将原容器的引用指向新的容器setArray(newElements);。这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。<br>CopyOnWriteArrayList使用volatile保证底层数组的可见性，当一个线程操作list时，给其上锁，操作完成后释放锁，保证只有一个线程进行写操作</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        Object[] elements = getArray();        <span class="hljs-keyword">int</span> len = elements.length;        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);        newElements[len] = e;        setArray(newElements);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre><h2 id="6-list遍历的几种方式？"><a href="#6-list遍历的几种方式？" class="headerlink" title="6.list遍历的几种方式？"></a>6.list遍历的几种方式？</h2><ol><li>普通fori 方式</li><li>for 循环<pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;    System.out.println(list.get(i));&#125;</code></pre></li><li>iterator迭代器<pre><code class="hljs java">Iterator&lt;String&gt; it = list.iterator();<span class="hljs-keyword">while</span> (it.hasNext()) &#123;  String str = it.next();  System.out.println(str);&#125;</code></pre></li><li>list.forEach（java8）<pre><code class="hljs java">list.forEach(item -&gt; &#123;    System.out.println(item);&#125;);</code></pre></li><li>list.stream().forEach（java8）<pre><code class="hljs java">list.stream().forEach(item -&gt; &#123;    System.out.println(item);&#125;);</code></pre></li><li>parallelStream().forEach（java8）<pre><code class="hljs java">list.parallelStream().forEach(item -&gt; &#123;    System.out.println(item);&#125;);</code></pre></li></ol><p><strong>总结：</strong></p><ul><li>推荐使用 fori，或iterator迭代器；</li><li>forEach 最耗时；</li><li>stream forEach 比较耗时和 for 差不多。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Java面试题</tag>
      
      <tag>ArrayList</tag>
      
      <tag>集合类不安全问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原子类AtomicInteger的ABA问题谈谈？原子更新引用知道吗？</title>
    <link href="/2020/11/15/java/ABA/"/>
    <url>/2020/11/15/java/ABA/</url>
    
    <content type="html"><![CDATA[<p>CAS —&gt; UnSafe —&gt; CAS底层思想 —&gt; ABA —&gt; 原子引用更新 —&gt; 如何规避ABA问题</p><h2 id="1-ABA问题是怎么产生的"><a href="#1-ABA问题是怎么产生的" class="headerlink" title="1.ABA问题是怎么产生的"></a>1.ABA问题是怎么产生的</h2><p>CAS会导致“ABA”。<strong>狸猫换太子</strong><br><img src="/resource/img/java/ABA.jpeg"><br>CAS算法实现一个重要前提需要提取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差内会导致数据的变化。<br>比如说一个线程t1从内存地址V中取出A，这时候另一个线程t2也从内存中取出A，并且线程t2进行了一些操作将值变成了B，然后线程t2又将V位置的数据变成A，这时候线程t1进行CAS操作发现内存中仍然是A，然后线程t1操作成功。<br><font color=#FF000>尽管线程t1的CAS操作成功，但是并不代表这个过程就是没有问题的。</font></p><h2 id="2-原子引用"><a href="#2-原子引用" class="headerlink" title="2.原子引用"></a>2.原子引用</h2><p>解决ABA问题的方法：<strong>理解原子引用</strong> + 新增一种机制，那就是修改版本号（类似于时间戳）<br>原子引用：<strong>AtomicReference</strong>类</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    String userName;    <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String userName, <span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userName = userName;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +                <span class="hljs-string">&quot;userName=&#x27;&quot;</span> + userName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, age=&quot;</span> + age +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReferenceDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        User z3 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">20</span>);        User l4 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">22</span>);        AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();        atomicReference.set(z3);        <span class="hljs-comment">// 如果当前值等于z3，那么替换为l4</span>        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get().toString());        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get().toString());    &#125;&#125;</code></pre><h2 id="3-时间戳的原子引用"><a href="#3-时间戳的原子引用" class="headerlink" title="3.时间戳的原子引用"></a>3.时间戳的原子引用</h2><p>ABA问题的解决办法：<strong>AtomicStampedReference类</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABADemo</span> </span>&#123;    <span class="hljs-keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">100</span>);    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始值和初始版本号</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;============================以下是ABA问题的产生=============================&quot;</span>);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 如果值等于expect，那么修改为update</span>            atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);            atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 暂停t2线程1秒钟，保证上面的t1线程完成一次ABA操作</span>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;            System.out.println(atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get());        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();        System.out.println(<span class="hljs-string">&quot;============================以下是ABA问题的解决=============================&quot;</span>);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t第1次版本号：&quot;</span> + atomicStampedReference.getStamp());            <span class="hljs-comment">// 暂停1秒t3线程</span>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;            atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t第2次版本号：&quot;</span> + atomicStampedReference.getStamp());            atomicStampedReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t第3次版本号：&quot;</span> + atomicStampedReference.getStamp());        &#125;, <span class="hljs-string">&quot;t3&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t第1次版本号：&quot;</span> + stamp);            <span class="hljs-comment">// 暂停3秒t4线程，保证上面的t3线程完成一次ABA操作</span>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;            <span class="hljs-keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>, stamp, stamp+<span class="hljs-number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t是否修改成功：&quot;</span> + result + <span class="hljs-string">&quot;\t当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t当前最新值：&quot;</span> + atomicStampedReference.getReference());        &#125;, <span class="hljs-string">&quot;t4&quot;</span>).start();    &#125;&#125;</code></pre><p>线程t1、t2对AtomicReference类的操作，最终compareAndSet的结果为true<br>线程t3、t4对AtomicStampedReference类的操作，最终compareAndSet的结果为false</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Java面试题</tag>
      
      <tag>ABA</tag>
      
      <tag>乐观锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS你知道吗？</title>
    <link href="/2020/11/10/java/CAS/"/>
    <url>/2020/11/10/java/CAS/</url>
    
    <content type="html"><![CDATA[<h2 id="CAS-代码演示"><a href="#CAS-代码演示" class="headerlink" title="CAS 代码演示"></a>CAS 代码演示</h2><p>CAS： <strong><em><font color=#FF000>比较并交换</font></em></strong>，需要用到 JUC 的 Atomic 包下面的类来进行操作。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);    <span class="hljs-comment">// main thread do thing...</span>    <span class="hljs-comment">// 两个参数：int expect, int update，如果atomicInteger的当前值expect == 5，那么就将atomicInteger的值改为update</span>    <span class="hljs-comment">// 如果线程的期望值跟主物理内存的真实值一样，那么就修改为线程的更新值，本次修改成功并返回true</span>    System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t current data:&quot;</span> + atomicInteger.get());    <span class="hljs-comment">// 本次修改失败并返回false</span>    System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;\t current data:&quot;</span> + atomicInteger.get());&#125;</code></pre><p>以上代码输出：</p><pre><code class="hljs text">true current data:2019false current data:2019</code></pre><h2 id="CAS-底层原理？谈谈你对-UnSafe-的理解"><a href="#CAS-底层原理？谈谈你对-UnSafe-的理解" class="headerlink" title="CAS 底层原理？谈谈你对 UnSafe 的理解"></a>CAS 底层原理？谈谈你对 UnSafe 的理解</h2><p>自旋锁、UnSafe类</p><h3 id="以atomicInteger-getAndIncrement-为例"><a href="#以atomicInteger-getAndIncrement-为例" class="headerlink" title="以atomicInteger.getAndIncrement() 为例"></a>以atomicInteger.getAndIncrement() 为例</h3><p>在之前讲volatile时，我们使用 <strong>atomicInteger.getAndIncrement();</strong> 解决了 <strong>number++;</strong> 在多线程环境下的线程安全问题，它的底层源码实现为：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Atomically increments by one the current value.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the previous value</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>);&#125;</code></pre><p>该方法中， <strong>this</strong> 指的是当前对象， <strong>valueOffset</strong> 指的是当前对象的内存偏移量（就是内存地址）</p><h3 id="UnSafe"><a href="#UnSafe" class="headerlink" title="UnSafe"></a>UnSafe</h3><p><img src="/resource/img/java/UnSafe.png"></p><ol><li><strong><em><font color=#FF000>UnSafe</font></em></strong> 是CAS的核心类，由于Java无法直接访问底层系统，需要通过本地（native）方法来访问，UnSafe相当于是一个后门，基于该类可以直接操作特定内存的数据。<font color=#FF000>UnSafe类存在于sun.misc包中</font>（存在于rt.jar，JDK从娘胎里就携带的最基础类），其内部方法操作可以想C的指针一样直接操作内存，因为Java中CAS操作执行依赖于UnSafe类的方法。<br><font color=#FF000><u><em>注意 UnSafe 类中所有方法都是native修饰的，也就是说UnSafe类中的方法都直接调用操作系统底层资源执行相应任务</em></u></font></li><li>变量<strong>valueOffset</strong> ，表示该变量值子啊内存中的<font color=#FF000>偏移地址</font>，因为UnSafe就是根据内存偏移地址获取数据的。<br><img src="/resource/img/java/valueOffset.png"></li><li>变量 value 用 volatile 修饰，保证了多线程中间的内存可见性。</li></ol><h2 id="CAS是什么？"><a href="#CAS是什么？" class="headerlink" title="CAS是什么？"></a>CAS是什么？</h2><p><strong>CAS</strong>的全称为<strong>Compare-And-Swap</strong>，<font color=#FF000>它是一条<strong>CPU</strong>并发原语</font>。<br>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。（一致性）</p><p><strong>CAS</strong>并发原语体现在<strong>Java</strong>语言中就是<strong>sun.misc.UnSafe</strong>类中的各个方法。调用<strong>UnSafe</strong>类中的<strong>CAS</strong>方法，JVM会帮我们实现出<font color=#8A2BE2><strong>CAS汇编指令</strong></font>。这是6一种完全依赖于<font color=#FF000>硬件</font>的功能，通过它实现了原子操作。<br>再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，<font color=#FF000>并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</font><br><img src="/resource/img/java/CAS.png"></p><pre><code class="hljs text">根据当前对象和当前对象的内存偏移量获取var5判断刚刚获取的var5是不是等于对象本身的值，相等的话，加上var4不相等的话 do while 继续，直到相等为止</code></pre><h3 id="unsafe-getAndAddInt"><a href="#unsafe-getAndAddInt" class="headerlink" title="unsafe.getAndAddInt();"></a>unsafe.getAndAddInt();</h3><p>var1 AtomicInteger对象本身。<br>var2 该对象值的引用地址。<br>var4 需要变动的数量。<br>var5 需要通过var1 var2 找出的主内存中真实存在的值，<br>用该对象当前的值与var5比较；<br>如果相同，更新var5+var4 并返回true，<br>如果不同，继续取值然后再比较，直到更新完成。<br><img src="/resource/img/java/unsafe-getAndAddInt.png"><br>假设线程A和线程B两个线程同时执行getAndAddInt操作（分别跑在不同CPU上）：</p><ol><li>AtomicInteger里面的value原始值是5，即主内存中AtomicInteger的value为5，根据JMM模型，线程A和线程B各自持有一份值为5的value的副本分别到各自的工作内存；</li><li>线程A通过getIntVolatile(var1, var2)拿到value值为5，这是线程A被挂起；</li><li>线程B也通过getIntVolatile(var1, var2)方法获取到value值为5，此时刚好线程B<font color=#FF000>没有被挂起</font>并执行compareAndSwapInt方法比较内存值也为5，成功修改主内存值为6，线程B打完收工，一切OK；</li><li>这是线程A恢复，执行compareAndSwapInt方法比较，发现自己手里的值数字5和主内存的值数字6不一致，说明该值已经被其它线程抢先一步修改过了，那A线程本次修改失败，<font color=#FF000>只能重新读取重新来一遍了</font>；</li><li>线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwapInt方法进行比较替换，直到成功。</li></ol><h3 id="底层汇编"><a href="#底层汇编" class="headerlink" title="底层汇编"></a>底层汇编</h3><p>UnSafe类中的compareAndSwapInt，是一个本地方法，该方法的实现位于unsafe.cpp中</p><pre><code class="hljs cpp">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))  UnsafeWrapper(<span class="hljs-string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);  oop p = JNIHandles::resolve(obj);  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);  <span class="hljs-keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;UNSAFE_END</code></pre><p><font color=#FF000>(Atomic::cmpxchg(x, addr, e)) == e;</font>使得操作不用加synchronized也能保证原子性；<br><font color=#0000F><br>先想办法拿到变量value在内存中的地址；<br>通过Atomic::cmpxchg实现比较替换，其中参数x是即将更新的值，参数e是原内存的值。<br></font></p><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><p><strong>1. 循环时间长开销很大</strong><br>我们可以看到getAndAddInt方法执行时，有个do while</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;    <span class="hljs-keyword">int</span> var5;    <span class="hljs-keyword">do</span> &#123;        var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));    <span class="hljs-keyword">return</span> var5;&#125;</code></pre><p>如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。<br><strong>2. 只能保证一个共享变量的原子操作</strong><br><strong>3. 引出来ABA问题</strong></p><h2 id="CAS-手写实现"><a href="#CAS-手写实现" class="headerlink" title="CAS 手写实现"></a>CAS 手写实现</h2><p>CAS 是采用 JNI(Java Native Interface) 的底层方法实现的，调用 c语言 来执行 cpu 的指令,而 cpu 则执行指令”cmpchg”执行来进行比较替换的操作，这是一个原子性的操作。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompareAndSwap</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * cas 原则: 原值 = 预期值 的情况下更新  新值</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 原值: count当前的值</span><span class="hljs-comment">     * 预期值: count最新的值</span><span class="hljs-comment">     * 新值: 需要更新的值</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">// 使用volatile保证可见性，实时获取count的值</span>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 实现方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">int</span> oldValue = getCount();        <span class="hljs-keyword">if</span> (!compareAndSwap(oldValue,oldValue + <span class="hljs-number">1</span>))&#123;        &#125;    &#125;    <span class="hljs-comment">// 比较原值和预期值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldValue,<span class="hljs-keyword">int</span> newValue)</span></span>&#123;        <span class="hljs-keyword">if</span> (getCount() == oldValue) &#123;            count = newValue;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">// 获取count值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            Thread thread = <span class="hljs-keyword">new</span> Thread(CompareAndSwap::request);            thread.start();        &#125;        System.out.println(count);    &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Java面试题</tag>
      
      <tag>CAS</tag>
      
      <tag>UnSafe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>请谈谈你对volatile的理解</title>
    <link href="/2020/11/03/java/volatile/"/>
    <url>/2020/11/03/java/volatile/</url>
    
    <content type="html"><![CDATA[<h2 id="volatile是java虚拟机提供的轻量级的同步机制"><a href="#volatile是java虚拟机提供的轻量级的同步机制" class="headerlink" title="volatile是java虚拟机提供的轻量级的同步机制"></a>volatile是java虚拟机提供的轻量级的同步机制</h2><ol><li>保证可见性</li><li><font color=#FF000>不保证原子性</font></li><li>禁止命令重排<br>首先我们要懂得：JVM是java虚拟机、JMM是java内存模型。JMM（java内存模型Java Memory Model，简称JMM）本身是一个抽象的概念<font color=#FF000>并不真是存在</font>，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</li></ol><p><strong><em>JMM关于同步的规定：</em></strong><br><strong>1.</strong> 线程解锁前，必须把共享变量的值刷新回主内存<br><strong>2.</strong> 线程加锁前，必须读取主内存的最新值到自己的工作内存<br><strong>3.</strong> 加锁解锁是同一把锁</p><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型（JMM）中规定所有的变量都存储在<font color=#FF000>主内存</font>，主内存是共享内存区域，所有线程的可以访问，<font color=#FF000>但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存</font>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的<font color=#0000F>变量副本拷贝</font>，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图：<br><img src="/resource/img/java/volatile.png"></p><h2 id="JMM你谈谈"><a href="#JMM你谈谈" class="headerlink" title="JMM你谈谈"></a>JMM你谈谈</h2><h3 id="JMM的可见性"><a href="#JMM的可见性" class="headerlink" title="JMM的可见性"></a>JMM的可见性</h3><ul><li>假设主内存中有一个Student对象，它的age = 25，现在有3个线程（t1、t2、t3）要操作age，3个线程首先将25拷贝回自己的工作内存（变量拷贝），线程t1在自己的工作内存中将age改为了37，之后t1将这个37写回主内存中，而此时此刻主内存的age是37 线程t2、t3的age是25</li><li>我们必须要有一种机制，只要有一个线程修改完自己工作内存的值并写回主内存，要及时通知其它线程，而这个及时通知就是<font color=#FF000>JMM内存模型的第一种特性：可见性</font>，只要有变动，大家立马可见，知道最新消息。</li><li>通过前面对JMM的介绍，我们知道：各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后再写回到主内存中的。这就可能存在一个线程A修改了共享变量X的值但还未写回主内存中时，另一个线程B又对主内存中的同一个共享变量X进行操作，但此时A线程工作内存中共享变量X对线程B来说是不可见的，这种工作内存与主内存同步延迟现象就造成了可见性问题。</li></ul><h3 id="VolatileDemo代码演示可见性"><a href="#VolatileDemo代码演示可见性" class="headerlink" title="VolatileDemo代码演示可见性"></a>VolatileDemo代码演示可见性</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.number = <span class="hljs-number">60</span>;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 1、验证volatile的可见性</span><span class="hljs-comment"> *  1.1 假设 int number = 0;，number变量之前根本没有添加volatile关键字修饰</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileDemo</span> </span>&#123;    <span class="hljs-comment">// main方法本身算一个main线程</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyData myData = <span class="hljs-keyword">new</span> MyData();        <span class="hljs-comment">// 创建一个新线程</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t come in&quot;</span>);            <span class="hljs-comment">// 暂停3秒钟后改变number的值</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            myData.add();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t update number value：&quot;</span> + myData.number);        &#125;, <span class="hljs-string">&quot;AAA&quot;</span>).start();        <span class="hljs-comment">// 第二个线程就是我们的main线程了</span>        <span class="hljs-keyword">while</span> (myData.number == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// main线程会一直在这里等待循环，直到number不为0</span>        &#125;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t mission is over，main get number value：&quot;</span> + myData.number);    &#125;&#125;</code></pre><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><font color=#FF000><strong>number++在多线程下是非线程安全的</strong></font>：因为该操作不具备原子性。<br><strong>原子性</strong>是指不可分割，完整性，即某个线程正在做某个业务时，中间不可以被加塞或者被分割。需要整体完整，要么同时成功，要么同时失败。</p><h3 id="VolatileDemo不保证原子性代码演示"><a href="#VolatileDemo不保证原子性代码演示" class="headerlink" title="VolatileDemo不保证原子性代码演示"></a>VolatileDemo不保证原子性代码演示</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 注意：此时number前面是加了volatile关键字修饰的，volatile不保证原子性</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPlus</span><span class="hljs-params">()</span> </span>&#123;        number++;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 2、验证volatile不保证原子性</span><span class="hljs-comment"> *  1.1 原子性指的是什么？</span><span class="hljs-comment"> *      不可分割，完整性，即某个线程正在做某个业务时，中间不可以被加塞或者被分割。需要整体完整，要么同时成功，要么同时失败。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileDemo</span> </span>&#123;    <span class="hljs-comment">// main方法本身算一个main线程</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyData myData = <span class="hljs-keyword">new</span> MyData();        <span class="hljs-comment">// 20个线程，每个线程++1000次，理想值是20000</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">1000</span>; j++) &#123;                    myData.addPlus();                &#125;            &#125;, String.valueOf(i)).start();        &#125;        <span class="hljs-comment">// 需要等待上面20个线程都全部计算完成后，再用main线程取得最终结果值</span>        <span class="hljs-keyword">while</span> (Thread.activeCount() &gt; <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 返回活动线程的当前线程的线程组中的数量</span>            Thread.yield(); <span class="hljs-comment">// 声明当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</span>        &#125;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t finally number value：&quot;</span> + myData.number);    &#125;&#125;</code></pre><p><strong><em><font color=#FF000>为什么volatile不保证原子性？</font></em></strong><br>&nbsp;&nbsp;因为会出现丢失写值的情况，一个线程在写会主内存时，其它线程被挂起，而volatile保证可见性，主内存还没来得及通知其它线程，另一个线程就它自己工作内存的值写进来了。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>&nbsp;&nbsp;计算机在执行程序时，为了提高性能，编译器和处理器常常会对<font color=#FF000>指令做重排</font>，一般分为一下3种：<br><img src="/resource/img/java/JMM_rearrangement.png"></p><ol><li>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。即<font color=#FF000>单线程环境下不用担心指令重排</font>；</li><li>处理器在进行重排序时必须要考虑指令之间的<font color=#FF000><strong>数据依赖性</strong></font>；</li><li>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。<br>比如说：现有 int a,b = 0;<br>按顺序，线程t1执行 a = b，线程2执行 b = 2;<br>理论上的结果是：a=0 b=2<br>由于在多线程环境下，编译器会自己做优化，对你写的代码进行重排序，会导致 a=2 b=2</li></ol><h3 id="线程安全性保证"><a href="#线程安全性保证" class="headerlink" title="线程安全性保证"></a>线程安全性保证</h3><p><strong>1、</strong> 工作内存与主内存同步延迟现象导致的可见性问题：<br>&nbsp;&nbsp;可以使用synchronized或volatile关键字解决，它们可以是一个线程<font color=#FF000>修改后的变量立即对其它线程可见</font>。<br><strong>2、</strong> 对于指令重排导致的可见性问题和有序性问题：<br>&nbsp;&nbsp;可以利用volatile关键字解决，因为volatile的另一个作用就是禁止重排序优化。</p><h2 id="你在哪些地方用过volatile"><a href="#你在哪些地方用过volatile" class="headerlink" title="你在哪些地方用过volatile"></a>你在哪些地方用过volatile</h2><h3 id="单例模式DCL代码"><a href="#单例模式DCL代码" class="headerlink" title="单例模式DCL代码"></a>单例模式DCL代码</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;    <span class="hljs-comment">// 单例模式</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SingletonDemo</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 我是构造函数SingletonDemo()&quot;</span>);    &#125;    <span class="hljs-comment">// DCL（Double Check Lock）:双端检锁机制</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 没加volatile前 可能打印：2   我是构造函数SingletonDemo()</span>            <span class="hljs-comment">// 加了volatile后 只会打印：1   我是构造函数SingletonDemo()</span>            <span class="hljs-keyword">synchronized</span> (SingletonDemo.class) &#123;                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) instance = <span class="hljs-keyword">new</span> SingletonDemo();            &#125;        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 单线程（main线程的操作动作....） 构造函数只会执行一次</span><span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span><span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span><span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span>        <span class="hljs-comment">// 并发多线程后，情况发生了很大的变化</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                SingletonDemo.getInstance();            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><h3 id="单例模式volatile分析"><a href="#单例模式volatile分析" class="headerlink" title="单例模式volatile分析"></a>单例模式volatile分析</h3><p><strong><font color=#FF000>DCL（Double Check Lock双端检锁机制）</font></strong> 不一定线程安全，原因是<font color=#FF000>有指令重排序的存在</font>，加入volatile可以禁止指令重排。<br>原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能还没完成初始化。<br><strong>instance = new SingletonDemo();可分为一下3步完成（伪代码）：</strong></p><pre><code class="hljs java">memory = allocate();<span class="hljs-comment">//1.分配对象内存空间</span>instance(memory);  <span class="hljs-comment">//2.初始化对象</span>instance = memory ;<span class="hljs-comment">//3.设置instance指向刚刚分配的内存地址，此时instance!=null</span></code></pre><p>步骤2和步骤3<font color=#FF000>不存在数据依赖关系</font>，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。</p><pre><code class="hljs java">memory = allocate();<span class="hljs-comment">//1.分配对象内存空间</span>instance = memory ;<span class="hljs-comment">//3.设置instance指向刚刚分配的内存地址，此时instance!=null，但是对象还没有初始化完成！</span>instance(memory);  <span class="hljs-comment">//2.初始化对象</span></code></pre><p>但是指令重排只会保证串行语义的执行的一致性（单线程），但并不会关心多线程间的语义一致性。<br><font color=#FF000>所以当一个线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。</font></p>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Java面试题</tag>
      
      <tag>JMM</tag>
      
      <tag>volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
